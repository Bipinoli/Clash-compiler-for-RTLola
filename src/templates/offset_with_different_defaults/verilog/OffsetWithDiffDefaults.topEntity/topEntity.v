/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.8.2. DO NOT MODIFY.
*/
`default_nettype none
`timescale 100fs/100fs
module topEntity
    ( // Inputs
      input wire  clk // clock
    , input wire  rst // reset
    , input wire  en // enable
    , input wire signed [7:0] input0_0
    , input wire  input0_1

      // Outputs
    , output wire signed [7:0] result_0_0
    , output wire  result_0_1
    , output wire signed [7:0] result_1_0
    , output wire  result_1_1
    );
  wire [10:0] result_2;
  // offset_with_different_defaults.hs:117:1-82
  wire  newA;
  wire [18:0] result_3;
  wire signed [7:0] result_4;
  // offset_with_different_defaults.hs:197:1-114
  wire  b;
  // offset_with_different_defaults.hs:197:1-114
  wire signed [7:0] t;
  wire  c$app_arg;
  wire  result_5;
  wire signed [7:0] result_6;
  // offset_with_different_defaults.hs:185:1-114
  wire  b_0;
  // offset_with_different_defaults.hs:185:1-114
  wire signed [7:0] t_0;
  wire  c$app_arg_0;
  // offset_with_different_defaults.hs:138:1-91
  wire  pacingA;
  wire  result_7;
  wire  result_8;
  // offset_with_different_defaults.hs:178:1-114
  reg [1:0] validOut = {1'b0,   1'b0};
  // offset_with_different_defaults.hs:178:1-114
  reg [15:0] dataOut = {8'sd0,   8'sd0};
  wire [17:0] result_9;
  // offset_with_different_defaults.hs:178:1-114
  wire [15:0] t_1;
  wire [15:0] result_10;
  // offset_with_different_defaults.hs:178:1-114
  wire [1:0] t_2;
  wire [1:0] result_11;
  wire  result_12;
  // offset_with_different_defaults.hs:136:24-25
  wire signed [63:0] \a# ;
  // offset_with_different_defaults.hs:138:1-91
  reg [2:0] c$state_app_arg;
  // offset_with_different_defaults.hs:138:1-91
  reg [2:0] state = 3'd0;
  // offset_with_different_defaults.hs:138:1-91
  wire [2:0] c$state_case_alt;
  // offset_with_different_defaults.hs:138:1-91
  wire [9:0] c$eventInfo_app_arg;
  // offset_with_different_defaults.hs:138:1-91
  reg [9:0] eventInfo = {{8'sd0,   1'b0},   1'b0};
  // offset_with_different_defaults.hs:138:1-91
  wire  isValidEvent;
  wire [11:0] result_13;
  reg [9:0] c$app_arg_1 = {{8'sd0,   1'b0},   1'b0};
  wire [9:0] c$case_alt;
  reg [9:0] c$case_alt_0;
  wire [9:0] c$case_alt_1;
  reg  c$app_arg_2 = 1'b0;
  wire  c$case_alt_2;
  reg  c$case_alt_3;
  reg  c$app_arg_3 = 1'b0;
  wire  c$case_alt_4;
  // offset_with_different_defaults.hs:54:1-78
  reg [59:0] buffer = {{{8'sd0,   1'b0},   1'b0},   {{8'sd0,   1'b0},   1'b0},   {{8'sd0,   1'b0},
                                                            1'b0},   {{8'sd0,
                                                                       1'b0},
                                                                      1'b0},
 {{8'sd0,   1'b0},   1'b0},   {{8'sd0,   1'b0},   1'b0}};
  // offset_with_different_defaults.hs:54:1-78
  wire [59:0] c$buffer_case_alt;
  // offset_with_different_defaults.hs:54:1-78
  wire [59:0] c$buffer_case_alt_0;
  // offset_with_different_defaults.hs:54:1-78
  wire [9:0] qData;
  // offset_with_different_defaults.hs:54:1-78
  reg signed [63:0] cursor = (64'sd0);
  // offset_with_different_defaults.hs:54:1-78
  wire signed [63:0] c$cursor_case_alt;
  // offset_with_different_defaults.hs:54:1-78
  wire  push;
  // offset_with_different_defaults.hs:54:1-78
  wire signed [63:0] c$cursor_case_alt_0;
  // offset_with_different_defaults.hs:54:1-78
  reg signed [63:0] c$cursor_case_alt_1;
  // offset_with_different_defaults.hs:54:1-78
  wire signed [63:0] c$cursor_case_alt_2;
  // offset_with_different_defaults.hs:54:1-78
  wire  c$cursor_case_scrut;
  // offset_with_different_defaults.hs:54:1-78
  wire signed [63:0] x;
  // offset_with_different_defaults.hs:54:1-78
  wire signed [63:0] c$cursor_case_alt_3;
  // offset_with_different_defaults.hs:54:1-78
  wire  pop;
  // offset_with_different_defaults.hs:54:1-78
  reg signed [63:0] c$cursor_case_alt_4;
  // offset_with_different_defaults.hs:54:1-78
  wire signed [63:0] c$cursor_case_alt_5;
  wire [8:0] input0;
  wire [1:0] c$vec;
  wire [15:0] c$vec_0;
  wire signed [63:0] c$tte_rhs;
  wire [1:0] c$vec_1;
  wire [15:0] c$vec_2;
  wire signed [63:0] c$tte_rhs_0;
  wire signed [63:0] c$tte_rhs_1;
  wire [23:0] t_projection;
  wire [2:0] t_projection_3;
  wire signed [63:0] c$tte_rhs_2;
  wire [69:0] c$buffer_case_alt_sel_alt_t_1;
  wire signed [63:0] c$tte_rhs_3;
  wire [17:0] result;
  wire [8:0] result_0;
  wire [8:0] result_1;

  assign input0 = {input0_0,   input0_1};

  assign result_2 = {newA | newA,   {input0,
                                     newA}};

  assign newA = input0[0:0];

  assign result_3 = {result_8,   {{result_6,
                                   c$app_arg},   {result_4,   c$app_arg}}};

  assign result_4 = b ? t : 8'sd100;

  assign c$vec = result_9[1:0];

  // index lit begin
  assign b = c$vec[2-1-0*1 -: 1];
  // index lit end

  assign c$vec_0 = result_9[17:2];

  // index lit begin
  assign t = c$vec_0[16-1-0*8 -: 8];
  // index lit end

  assign c$app_arg = result_5 & pacingA;

  assign c$tte_rhs = (\a#  == 64'sd4) ? 64'sd1 : 64'sd0;

  assign result_5 = c$tte_rhs[0];

  assign result_6 = b_0 ? t_0 : 8'sd10;

  assign c$vec_1 = result_9[1:0];

  // index lit begin
  assign b_0 = c$vec_1[2-1-0*1 -: 1];
  // index lit end

  assign c$vec_2 = result_9[17:2];

  // index lit begin
  assign t_0 = c$vec_2[16-1-0*8 -: 8];
  // index lit end

  assign c$app_arg_0 = result_7 & pacingA;

  assign pacingA = eventInfo[0:0];

  assign c$tte_rhs_0 = (\a#  == 64'sd3) ? 64'sd1 : 64'sd0;

  assign result_7 = c$tte_rhs_0[0];

  assign c$tte_rhs_1 = (\a#  == 64'sd0) ? 64'sd1 : 64'sd0;

  assign result_8 = c$tte_rhs_1[0];

  // register begin
  always @(posedge clk or  posedge  rst) begin : validOut_register
    if ( rst) begin
      validOut <= {1'b0,   1'b0};
    end else if (en) begin
      validOut <= result_11;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : dataOut_register
    if ( rst) begin
      dataOut <= {8'sd0,   8'sd0};
    end else if (en) begin
      dataOut <= result_10;
    end
  end
  // register end

  assign result_9 = {dataOut,   validOut};

  assign t_projection = ({dataOut,$signed(eventInfo[9:2])});

  assign t_1 = t_projection[15:0];

  assign result_10 = result_12 ? t_1 : dataOut;

  assign t_projection_3 = ({validOut,1'b1});

  assign t_2 = t_projection_3[1:0];

  assign result_11 = result_12 ? t_2 : validOut;

  assign c$tte_rhs_2 = (\a#  == 64'sd2) ? 64'sd1 : 64'sd0;

  assign result_12 = c$tte_rhs_2[0];

  assign \a#  = $unsigned(state);

  always @(*) begin
    case(state)
      3'b000 : c$state_app_arg = 3'd1;
      3'b001 : c$state_app_arg = c$state_case_alt;
      3'b010 : c$state_app_arg = 3'd3;
      3'b011 : c$state_app_arg = 3'd4;
      default : c$state_app_arg = 3'd0;
    endcase
  end

  // register begin
  always @(posedge clk or  posedge  rst) begin : state_register
    if ( rst) begin
      state <= 3'd0;
    end else if (en) begin
      state <= c$state_app_arg;
    end
  end
  // register end

  assign c$state_case_alt = isValidEvent ? 3'd2 : 3'd0;

  assign c$eventInfo_app_arg = isValidEvent ? result_13[9:0] : eventInfo;

  // register begin
  always @(posedge clk or  posedge  rst) begin : eventInfo_register
    if ( rst) begin
      eventInfo <= {{8'sd0,   1'b0},   1'b0};
    end else if (en) begin
      eventInfo <= c$eventInfo_app_arg;
    end
  end
  // register end

  assign isValidEvent = result_13[10:10];

  assign result_13 = {c$app_arg_3,   c$app_arg_2,
                      c$app_arg_1};

  // register begin
  always @(posedge clk or  posedge  rst) begin : c$app_arg_1_register
    if ( rst) begin
      c$app_arg_1 <= {{8'sd0,   1'b0},   1'b0};
    end else if (en) begin
      c$app_arg_1 <= c$case_alt;
    end
  end
  // register end

  assign c$case_alt = pop ? c$case_alt_0 : {{8'sd0,
                                             1'b0},   1'b0};

  always @(*) begin
    case(x)
      64'sd0 : c$case_alt_0 = {{8'sd0,   1'b0},
                               1'b0};
      default : c$case_alt_0 = c$case_alt_1;
    endcase
  end

  // index begin
  wire [9:0] vecArray [0:6-1];
  genvar i;
  generate
  for (i=0; i < 6; i=i+1) begin : mk_array
    assign vecArray[(6-1)-i] = buffer[i*10+:10];
  end
  endgenerate
  assign c$case_alt_1 = vecArray[c$cursor_case_alt_5];
  // index end

  // register begin
  always @(posedge clk or  posedge  rst) begin : c$app_arg_2_register
    if ( rst) begin
      c$app_arg_2 <= 1'b0;
    end else if (en) begin
      c$app_arg_2 <= c$case_alt_2;
    end
  end
  // register end

  assign c$case_alt_2 = pop ? c$case_alt_3 : 1'b0;

  always @(*) begin
    case(x)
      64'sd0 : c$case_alt_3 = 1'b0;
      default : c$case_alt_3 = 1'b1;
    endcase
  end

  // register begin
  always @(posedge clk or  posedge  rst) begin : c$app_arg_3_register
    if ( rst) begin
      c$app_arg_3 <= 1'b0;
    end else if (en) begin
      c$app_arg_3 <= c$case_alt_4;
    end
  end
  // register end

  assign c$case_alt_4 = push ? c$cursor_case_scrut : 1'b0;

  // register begin
  always @(posedge clk or  posedge  rst) begin : buffer_register
    if ( rst) begin
      buffer <= {{{8'sd0,   1'b0},   1'b0},   {{8'sd0,   1'b0},   1'b0},   {{8'sd0,   1'b0},
                                                              1'b0},   {{8'sd0,
                                                                         1'b0},
                                                                        1'b0},
   {{8'sd0,   1'b0},   1'b0},   {{8'sd0,   1'b0},   1'b0}};
    end else if (en) begin
      buffer <= c$buffer_case_alt;
    end
  end
  // register end

  assign c$buffer_case_alt = push ? c$buffer_case_alt_0 : buffer;

  assign c$buffer_case_alt_sel_alt_t_1 = ({qData,buffer});

  assign c$buffer_case_alt_0 = c$cursor_case_scrut ? c$buffer_case_alt_sel_alt_t_1[69:10] : buffer;

  assign qData = result_2[9:0];

  // register begin
  always @(posedge clk or  posedge  rst) begin : cursor_register
    if ( rst) begin
      cursor <= (64'sd0);
    end else if (en) begin
      cursor <= c$cursor_case_alt;
    end
  end
  // register end

  assign c$cursor_case_alt = push ? c$cursor_case_alt_0 : c$cursor_case_alt_3;

  assign push = result_2[10:10];

  assign c$cursor_case_alt_0 = pop ? c$cursor_case_alt_1 : c$cursor_case_alt_2;

  always @(*) begin
    case(x)
      64'sd0 : c$cursor_case_alt_1 = 64'sd1;
      default : c$cursor_case_alt_1 = cursor;
    endcase
  end

  assign c$cursor_case_alt_2 = c$cursor_case_scrut ? ((x + 64'sd1)) : cursor;

  assign c$tte_rhs_3 = (x != 64'sd6) ? 64'sd1 : 64'sd0;

  assign c$cursor_case_scrut = c$tte_rhs_3[0];

  assign x = cursor;

  assign c$cursor_case_alt_3 = pop ? c$cursor_case_alt_4 : cursor;

  assign pop = result_3[18:18];

  always @(*) begin
    case(x)
      64'sd0 : c$cursor_case_alt_4 = 64'sd0;
      default : c$cursor_case_alt_4 = c$cursor_case_alt_5;
    endcase
  end

  assign c$cursor_case_alt_5 = (x - 64'sd1);

  assign result = result_3[17:0];

  assign result_0 = result[17:9];

  assign result_1 = result[8:0];

  assign result_0_0 = $signed(result_0[8:1]);

  assign result_0_1 = result_0[0:0];

  assign result_1_0 = $signed(result_1[8:1]);

  assign result_1_1 = result_1[0:0];


endmodule

