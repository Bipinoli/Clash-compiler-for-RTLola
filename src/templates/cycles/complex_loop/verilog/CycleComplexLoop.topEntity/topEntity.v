/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.8.2. DO NOT MODIFY.
*/
`default_nettype none
`timescale 100fs/100fs
module topEntity
    ( // Inputs
      input wire  clk // clock
    , input wire  rst // reset
    , input wire  en // enable
    , input wire signed [7:0] input0_0_0
    , input wire  input0_0_1
    , input wire signed [7:0] input0_1_0
    , input wire  input0_1_1

      // Outputs
    , output wire signed [7:0] result_0_0_0
    , output wire  result_0_0_1
    , output wire signed [7:0] result_0_1_0
    , output wire  result_0_1_1
    , output wire signed [7:0] result_0_2_0
    , output wire  result_0_2_1
    , output wire signed [7:0] result_0_3_0
    , output wire  result_0_3_1
    , output wire signed [7:0] result_0_4_0
    , output wire  result_0_4_1
    , output wire signed [7:0] result_0_5_0
    , output wire  result_0_5_1
    , output wire  result_1_0
    , output wire  result_1_1
    , output wire  result_1_2
    , output wire  result_1_3
    , output wire [2:0] result_1_4
    , output wire signed [7:0] result_1_5
    , output wire signed [7:0] result_1_6
    , output wire  result_1_7
    );
  wire signed [63:0] result_2;
  wire signed [63:0] x;
  reg signed [63:0] result_3 = (64'sd0);
  wire [21:0] result_4;
  // complex_loop.hs:164:1-82
  wire  newA;
  // complex_loop.hs:164:1-82
  wire  newB;
  // complex_loop.hs:164:1-82
  wire  pacingAAndB;
  // complex_loop.hs:164:1-82
  wire  timer1Over;
  wire [74:0] result_5;
  // complex_loop.hs:317:1-134
  wire  eta;
  // complex_loop.hs:317:1-134
  wire signed [7:0] c$out_case_alt;
  // complex_loop.hs:317:1-134
  wire signed [7:0] c$out_app_arg;
  // complex_loop.hs:317:1-134
  reg signed [7:0] out = 8'sd0;
  // complex_loop.hs:200:1-125
  wire  pacing1Hz;
  // complex_loop.hs:311:1-116
  reg signed [7:0] out_0 = 8'sd0;
  // complex_loop.hs:311:1-116
  wire signed [7:0] t;
  wire signed [7:0] result_6;
  // complex_loop.hs:200:1-125
  wire  outAktvCDEG;
  wire  result_7;
  wire  result_8;
  wire [1:0] result_9;
  wire signed [7:0] result_10;
  wire [15:0] result_11;
  wire [17:0] result_12;
  // complex_loop.hs:287:1-156
  reg [15:0] out_1 = {8'sd0,   8'sd0};
  // complex_loop.hs:287:1-156
  reg [1:0] outValid = {1'b0,   1'b0};
  // complex_loop.hs:287:1-156
  wire  b;
  // complex_loop.hs:287:1-156
  wire [1:0] t_0;
  // complex_loop.hs:287:1-156
  wire [15:0] t_1;
  // complex_loop.hs:287:1-156
  wire signed [7:0] t_2;
  // complex_loop.hs:265:1-144
  wire signed [7:0] c$t_app_arg;
  wire signed [7:0] result_13;
  // complex_loop.hs:265:1-144
  reg signed [7:0] out_2 = 8'sd0;
  // complex_loop.hs:265:1-144
  wire signed [7:0] t_3;
  // complex_loop.hs:274:1-144
  wire  c$outValid_app_arg;
  wire signed [7:0] result_14;
  wire signed [7:0] result_15;
  wire [8:0] result_16;
  // complex_loop.hs:274:1-144
  reg signed [7:0] out_3 = 8'sd0;
  // complex_loop.hs:274:1-144
  reg  outValid_0 = 1'b0;
  // complex_loop.hs:274:1-144
  wire  b_0;
  // complex_loop.hs:274:1-144
  wire signed [7:0] t_4;
  // complex_loop.hs:274:1-144
  wire signed [7:0] t_5;
  // complex_loop.hs:200:1-125
  wire signed [7:0] b_1;
  // complex_loop.hs:200:1-125
  wire  c$evalD_app_arg;
  // complex_loop.hs:200:1-125
  wire  c$evalE_app_arg;
  // complex_loop.hs:200:1-125
  wire  pacingAAndB_0;
  wire  result_17;
  // complex_loop.hs:300:1-136
  wire  eta_0;
  wire signed [7:0] result_18;
  wire signed [7:0] result_19;
  // complex_loop.hs:300:1-136
  reg signed [7:0] out_4 = 8'sd0;
  // complex_loop.hs:300:1-136
  wire  b_2;
  // complex_loop.hs:300:1-136
  wire signed [7:0] t_6;
  // complex_loop.hs:300:1-136
  wire signed [7:0] t_7;
  // complex_loop.hs:200:1-125
  wire  pacingA;
  wire  result_20;
  // complex_loop.hs:259:1-116
  reg [1:0] validOut = {1'b0,   1'b0};
  // complex_loop.hs:259:1-116
  reg [15:0] dataOut = {8'sd0,   8'sd0};
  wire [17:0] result_21;
  // complex_loop.hs:259:1-116
  wire [15:0] t_8;
  wire [15:0] result_22;
  // complex_loop.hs:259:1-116
  wire [1:0] t_9;
  wire [1:0] result_23;
  // complex_loop.hs:200:1-125
  wire signed [7:0] a;
  wire  result_24;
  // complex_loop.hs:198:24-25
  wire signed [63:0] \a# ;
  // complex_loop.hs:200:1-125
  reg [2:0] c$state_app_arg;
  // complex_loop.hs:200:1-125
  reg [2:0] state = 3'd0;
  // complex_loop.hs:200:1-125
  wire [2:0] c$state_case_alt;
  // complex_loop.hs:200:1-125
  wire [20:0] c$eventInfo_app_arg;
  // complex_loop.hs:200:1-125
  reg [20:0] eventInfo = {{{8'sd0,   1'b0},   {8'sd0,   1'b0}},   {1'b0,   1'b0,   1'b0}};
  wire [22:0] result_25;
  reg [20:0] c$app_arg = {{{8'sd0,   1'b0},   {8'sd0,   1'b0}},   {1'b0,   1'b0,   1'b0}};
  wire [20:0] c$case_alt;
  reg [20:0] c$case_alt_0;
  wire [20:0] c$case_alt_1;
  reg  c$app_arg_0 = 1'b0;
  wire  c$case_alt_2;
  reg  c$case_alt_3;
  reg  c$app_arg_1 = 1'b0;
  wire  c$case_alt_4;
  // complex_loop.hs:96:1-78
  reg [125:0] buffer = {{{{8'sd0,   1'b0},   {8'sd0,   1'b0}},   {1'b0,   1'b0,   1'b0}},   {{{8'sd0,
                                                                        1'b0},
                                                                       {8'sd0,
                                                                        1'b0}},
                                                                      {1'b0,
                                                                       1'b0,
                                                                       1'b0}},
 {{{8'sd0,   1'b0},   {8'sd0,   1'b0}},   {1'b0,   1'b0,   1'b0}},   {{{8'sd0,
                                                                        1'b0},
                                                                       {8'sd0,
                                                                        1'b0}},
                                                                      {1'b0,
                                                                       1'b0,
                                                                       1'b0}},
 {{{8'sd0,   1'b0},   {8'sd0,   1'b0}},   {1'b0,   1'b0,   1'b0}},   {{{8'sd0,
                                                                        1'b0},
                                                                       {8'sd0,
                                                                        1'b0}},
                                                                      {1'b0,
                                                                       1'b0,
                                                                       1'b0}}};
  // complex_loop.hs:96:1-78
  wire [125:0] c$buffer_case_alt;
  // complex_loop.hs:96:1-78
  wire [125:0] c$buffer_case_alt_0;
  // complex_loop.hs:96:1-78
  wire [20:0] qData;
  // complex_loop.hs:96:1-78
  reg signed [63:0] cursor = (64'sd0);
  // complex_loop.hs:96:1-78
  wire signed [63:0] c$cursor_case_alt;
  // complex_loop.hs:96:1-78
  wire signed [63:0] c$cursor_case_alt_0;
  // complex_loop.hs:96:1-78
  reg signed [63:0] c$cursor_case_alt_1;
  // complex_loop.hs:96:1-78
  wire signed [63:0] c$cursor_case_alt_2;
  // complex_loop.hs:96:1-78
  wire  c$cursor_case_scrut;
  // complex_loop.hs:96:1-78
  wire signed [63:0] x_0;
  // complex_loop.hs:96:1-78
  wire signed [63:0] c$cursor_case_alt_3;
  // complex_loop.hs:96:1-78
  reg signed [63:0] c$cursor_case_alt_4;
  // complex_loop.hs:96:1-78
  wire signed [63:0] c$cursor_case_alt_5;
  // complex_loop.hs:331:1-138
  wire  qPopValid;
  // complex_loop.hs:331:1-138
  wire  qPush;
  // complex_loop.hs:331:1-138
  wire  qPop;
  wire [17:0] input0;
  wire [15:0] c$vec;
  wire [1:0] c$vec_0;
  wire [15:0] c$vec_1;
  wire signed [63:0] c$tte_rhs;
  wire signed [63:0] c$tte_rhs_0;
  wire [1:0] c$vec_2;
  wire [2:0] t_projection;
  wire [23:0] t_projection_0;
  wire [15:0] c$vec_3;
  wire [1:0] c$vec_4;
  wire [15:0] c$vec_5;
  wire signed [63:0] c$tte_rhs_1;
  wire [1:0] c$vec_6;
  wire [15:0] c$vec_7;
  wire signed [63:0] c$tte_rhs_2;
  wire [23:0] t_projection_1;
  wire [2:0] t_projection_2;
  wire signed [63:0] c$tte_rhs_3;
  wire [146:0] c$buffer_case_alt_sel_alt_t_1;
  wire signed [63:0] c$tte_rhs_4;
  wire [77:0] result;
  wire [53:0] result_0;
  wire [8:0] result_0_0;
  wire [8:0] result_0_1;
  wire [8:0] result_0_2;
  wire [8:0] result_0_3;
  wire [8:0] result_0_4;
  wire [8:0] result_0_5;
  wire [23:0] result_1;

  assign input0 = {{input0_0_0,   input0_0_1},
                   {input0_1_0,   input0_1_1}};

  assign result_2 = timer1Over ? (64'sd2000) : ((x + 64'sd2000));

  assign x = result_3;

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_3_register
    if ( rst) begin
      result_3 <= (64'sd0);
    end else if (en) begin
      result_3 <= result_2;
    end
  end
  // register end

  assign result_4 = {(newA | newB) | (newA | (pacingAAndB | timer1Over)),
                     {input0,   {newA,   pacingAAndB,
                                 timer1Over}}};

  assign newA = input0[9:9];

  assign newB = input0[0:0];

  assign pacingAAndB = newA & newB;

  assign timer1Over = result_3 >= (64'sd1000000);

  assign c$vec = result_12[17:2];

  assign result_5 = {result_7,   {{out_2,
                                   outAktvCDEG},   {$signed(result_16[8:1]),
                                                    outAktvCDEG},   {$signed(c$vec[8-1:0]),
                                                                     outAktvCDEG},   {out_4,   result_8 & pacingA},
                                  {out_0,   outAktvCDEG},   {out,
                                                             result_8 & pacing1Hz}},   {state,   a,   b_1,
                                                                                        pacing1Hz}};

  assign eta = result_20 & pacing1Hz;

  assign c$vec_0 = result_21[1:0];

  assign c$vec_1 = result_21[17:2];

  assign c$out_case_alt = (c$vec_0[1-1:0]) ? ($signed(c$vec_1[8-1:0])) : 8'sd6;

  assign c$out_app_arg = eta ? c$out_case_alt : out;

  // register begin
  always @(posedge clk or  posedge  rst) begin : out_register
    if ( rst) begin
      out <= 8'sd0;
    end else if (en) begin
      out <= c$out_app_arg;
    end
  end
  // register end

  assign pacing1Hz = eventInfo[0:0];

  // register begin
  always @(posedge clk or  posedge  rst) begin : out_0_register
    if ( rst) begin
      out_0 <= 8'sd0;
    end else if (en) begin
      out_0 <= result_6;
    end
  end
  // register end

  assign t = b_1 + out_4;

  assign result_6 = c$evalE_app_arg ? t : out_0;

  assign outAktvCDEG = result_8 & pacingAAndB_0;

  assign c$tte_rhs = (\a#  == 64'sd0) ? 64'sd1 : 64'sd0;

  assign result_7 = c$tte_rhs[0];

  assign c$tte_rhs_0 = (\a#  == 64'sd5) ? 64'sd1 : 64'sd0;

  assign result_8 = c$tte_rhs_0[0];

  assign result_9 = c$evalE_app_arg ? t_0 : outValid;

  assign result_10 = b ? t_2 : 8'sd1;

  assign result_11 = c$evalE_app_arg ? t_1 : out_1;

  assign result_12 = {out_1,   outValid};

  // register begin
  always @(posedge clk or  posedge  rst) begin : out_1_register
    if ( rst) begin
      out_1 <= {8'sd0,   8'sd0};
    end else if (en) begin
      out_1 <= result_11;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : outValid_register
    if ( rst) begin
      outValid <= {1'b0,   1'b0};
    end else if (en) begin
      outValid <= result_9;
    end
  end
  // register end

  assign c$vec_2 = result_21[1:0];

  // index lit begin
  assign b = c$vec_2[2-1-0*1 -: 1];
  // index lit end

  assign t_projection = ({outValid,1'b1});

  assign t_0 = t_projection[1:0];

  assign t_projection_0 = ({out_1,result_10 + out_2});

  assign t_1 = t_projection_0[15:0];

  assign c$vec_3 = result_21[17:2];

  // index lit begin
  assign t_2 = c$vec_3[16-1-0*8 -: 8];
  // index lit end

  assign c$t_app_arg = result_16[0:0] ? $signed(result_16[8:1]) : 8'sd3;

  assign result_13 = c$evalD_app_arg ? t_3 : out_2;

  // register begin
  always @(posedge clk or  posedge  rst) begin : out_2_register
    if ( rst) begin
      out_2 <= 8'sd0;
    end else if (en) begin
      out_2 <= result_13;
    end
  end
  // register end

  assign t_3 = (a + b_1) + c$t_app_arg;

  assign c$outValid_app_arg = c$evalD_app_arg ? 1'b1 : outValid_0;

  assign result_14 = b_0 ? t_5 : 8'sd4;

  assign result_15 = c$evalD_app_arg ? t_4 : out_3;

  assign result_16 = {out_3,   outValid_0};

  // register begin
  always @(posedge clk or  posedge  rst) begin : out_3_register
    if ( rst) begin
      out_3 <= 8'sd0;
    end else if (en) begin
      out_3 <= result_15;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : outValid_0_register
    if ( rst) begin
      outValid_0 <= 1'b0;
    end else if (en) begin
      outValid_0 <= c$outValid_app_arg;
    end
  end
  // register end

  assign c$vec_4 = result_12[1:0];

  // index lit begin
  assign b_0 = c$vec_4[2-1-0*1 -: 1];
  // index lit end

  assign t_4 = b_1 + result_14;

  assign c$vec_5 = result_12[17:2];

  // index lit begin
  assign t_5 = c$vec_5[16-1-0*8 -: 8];
  // index lit end

  assign b_1 = $signed(eventInfo[11:4]);

  assign c$evalD_app_arg = result_20 & pacingAAndB_0;

  assign c$evalE_app_arg = result_17 & pacingAAndB_0;

  assign pacingAAndB_0 = eventInfo[1:1];

  assign c$tte_rhs_1 = (\a#  == 64'sd4) ? 64'sd1 : 64'sd0;

  assign result_17 = c$tte_rhs_1[0];

  assign eta_0 = result_20 & pacingA;

  assign result_18 = b_2 ? t_7 : 8'sd0;

  assign result_19 = eta_0 ? t_6 : out_4;

  // register begin
  always @(posedge clk or  posedge  rst) begin : out_4_register
    if ( rst) begin
      out_4 <= 8'sd0;
    end else if (en) begin
      out_4 <= result_19;
    end
  end
  // register end

  assign c$vec_6 = result_21[1:0];

  // index lit begin
  assign b_2 = c$vec_6[2-1-0*1 -: 1];
  // index lit end

  assign t_6 = a + result_18;

  assign c$vec_7 = result_21[17:2];

  // index lit begin
  assign t_7 = c$vec_7[16-1-0*8 -: 8];
  // index lit end

  assign pacingA = eventInfo[2:2];

  assign c$tte_rhs_2 = (\a#  == 64'sd3) ? 64'sd1 : 64'sd0;

  assign result_20 = c$tte_rhs_2[0];

  // register begin
  always @(posedge clk or  posedge  rst) begin : validOut_register
    if ( rst) begin
      validOut <= {1'b0,   1'b0};
    end else if (en) begin
      validOut <= result_23;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : dataOut_register
    if ( rst) begin
      dataOut <= {8'sd0,   8'sd0};
    end else if (en) begin
      dataOut <= result_22;
    end
  end
  // register end

  assign result_21 = {dataOut,   validOut};

  assign t_projection_1 = ({dataOut,a});

  assign t_8 = t_projection_1[15:0];

  assign result_22 = result_24 ? t_8 : dataOut;

  assign t_projection_2 = ({validOut,1'b1});

  assign t_9 = t_projection_2[1:0];

  assign result_23 = result_24 ? t_9 : validOut;

  assign a = $signed(eventInfo[20:13]);

  assign c$tte_rhs_3 = (\a#  == 64'sd2) ? 64'sd1 : 64'sd0;

  assign result_24 = c$tte_rhs_3[0];

  assign \a#  = $unsigned(state);

  always @(*) begin
    case(state)
      3'b000 : c$state_app_arg = 3'd1;
      3'b001 : c$state_app_arg = c$state_case_alt;
      3'b010 : c$state_app_arg = 3'd3;
      3'b011 : c$state_app_arg = 3'd4;
      3'b100 : c$state_app_arg = 3'd5;
      default : c$state_app_arg = 3'd0;
    endcase
  end

  // register begin
  always @(posedge clk or  posedge  rst) begin : state_register
    if ( rst) begin
      state <= 3'd0;
    end else if (en) begin
      state <= c$state_app_arg;
    end
  end
  // register end

  assign c$state_case_alt = qPopValid ? 3'd2 : 3'd0;

  assign c$eventInfo_app_arg = qPopValid ? result_25[20:0] : eventInfo;

  // register begin
  always @(posedge clk or  posedge  rst) begin : eventInfo_register
    if ( rst) begin
      eventInfo <= {{{8'sd0,   1'b0},   {8'sd0,   1'b0}},   {1'b0,   1'b0,   1'b0}};
    end else if (en) begin
      eventInfo <= c$eventInfo_app_arg;
    end
  end
  // register end

  assign result_25 = {c$app_arg_1,   c$app_arg_0,
                      c$app_arg};

  // register begin
  always @(posedge clk or  posedge  rst) begin : c$app_arg_register
    if ( rst) begin
      c$app_arg <= {{{8'sd0,   1'b0},   {8'sd0,   1'b0}},   {1'b0,   1'b0,   1'b0}};
    end else if (en) begin
      c$app_arg <= c$case_alt;
    end
  end
  // register end

  assign c$case_alt = qPop ? c$case_alt_0 : {{{8'sd0,
                                               1'b0},   {8'sd0,   1'b0}},   {1'b0,   1'b0,
                                                                             1'b0}};

  always @(*) begin
    case(x_0)
      64'sd0 : c$case_alt_0 = {{{8'sd0,   1'b0},
                                {8'sd0,   1'b0}},   {1'b0,   1'b0,   1'b0}};
      default : c$case_alt_0 = c$case_alt_1;
    endcase
  end

  // index begin
  wire [20:0] vecArray [0:6-1];
  genvar i;
  generate
  for (i=0; i < 6; i=i+1) begin : mk_array
    assign vecArray[(6-1)-i] = buffer[i*21+:21];
  end
  endgenerate
  assign c$case_alt_1 = vecArray[c$cursor_case_alt_5];
  // index end

  // register begin
  always @(posedge clk or  posedge  rst) begin : c$app_arg_0_register
    if ( rst) begin
      c$app_arg_0 <= 1'b0;
    end else if (en) begin
      c$app_arg_0 <= c$case_alt_2;
    end
  end
  // register end

  assign c$case_alt_2 = qPop ? c$case_alt_3 : 1'b0;

  always @(*) begin
    case(x_0)
      64'sd0 : c$case_alt_3 = 1'b0;
      default : c$case_alt_3 = 1'b1;
    endcase
  end

  // register begin
  always @(posedge clk or  posedge  rst) begin : c$app_arg_1_register
    if ( rst) begin
      c$app_arg_1 <= 1'b0;
    end else if (en) begin
      c$app_arg_1 <= c$case_alt_4;
    end
  end
  // register end

  assign c$case_alt_4 = qPush ? c$cursor_case_scrut : 1'b0;

  // register begin
  always @(posedge clk or  posedge  rst) begin : buffer_register
    if ( rst) begin
      buffer <= {{{{8'sd0,   1'b0},   {8'sd0,   1'b0}},   {1'b0,   1'b0,   1'b0}},   {{{8'sd0,
                                                                          1'b0},
                                                                         {8'sd0,
                                                                          1'b0}},
                                                                        {1'b0,
                                                                         1'b0,
                                                                         1'b0}},
   {{{8'sd0,   1'b0},   {8'sd0,   1'b0}},   {1'b0,   1'b0,   1'b0}},   {{{8'sd0,
                                                                          1'b0},
                                                                         {8'sd0,
                                                                          1'b0}},
                                                                        {1'b0,
                                                                         1'b0,
                                                                         1'b0}},
   {{{8'sd0,   1'b0},   {8'sd0,   1'b0}},   {1'b0,   1'b0,   1'b0}},   {{{8'sd0,
                                                                          1'b0},
                                                                         {8'sd0,
                                                                          1'b0}},
                                                                        {1'b0,
                                                                         1'b0,
                                                                         1'b0}}};
    end else if (en) begin
      buffer <= c$buffer_case_alt;
    end
  end
  // register end

  assign c$buffer_case_alt = qPush ? c$buffer_case_alt_0 : buffer;

  assign c$buffer_case_alt_sel_alt_t_1 = ({qData,buffer});

  assign c$buffer_case_alt_0 = c$cursor_case_scrut ? c$buffer_case_alt_sel_alt_t_1[146:21] : buffer;

  assign qData = result_4[20:0];

  // register begin
  always @(posedge clk or  posedge  rst) begin : cursor_register
    if ( rst) begin
      cursor <= (64'sd0);
    end else if (en) begin
      cursor <= c$cursor_case_alt;
    end
  end
  // register end

  assign c$cursor_case_alt = qPush ? c$cursor_case_alt_0 : c$cursor_case_alt_3;

  assign c$cursor_case_alt_0 = qPop ? c$cursor_case_alt_1 : c$cursor_case_alt_2;

  always @(*) begin
    case(x_0)
      64'sd0 : c$cursor_case_alt_1 = 64'sd1;
      default : c$cursor_case_alt_1 = cursor;
    endcase
  end

  assign c$cursor_case_alt_2 = c$cursor_case_scrut ? ((x_0 + 64'sd1)) : cursor;

  assign c$tte_rhs_4 = (x_0 != 64'sd6) ? 64'sd1 : 64'sd0;

  assign c$cursor_case_scrut = c$tte_rhs_4[0];

  assign x_0 = cursor;

  assign c$cursor_case_alt_3 = qPop ? c$cursor_case_alt_4 : cursor;

  always @(*) begin
    case(x_0)
      64'sd0 : c$cursor_case_alt_4 = 64'sd0;
      default : c$cursor_case_alt_4 = c$cursor_case_alt_5;
    endcase
  end

  assign c$cursor_case_alt_5 = (x_0 - 64'sd1);

  assign result = {result_5[73:20],   {qPush,
                                       qPop,   result_25[22:22],   qPopValid,
                                       result_5[19:17],   $signed(result_5[16:9]),
                                       $signed(result_5[8:1]),   result_5[0:0]}};

  assign qPopValid = result_25[21:21];

  assign qPush = result_4[21:21];

  assign qPop = result_5[74:74];

  assign result_0 = result[77:24];

  assign result_1 = result[23:0];

  assign result_0_0 = result_0[53:45];

  assign result_0_1 = result_0[44:36];

  assign result_0_2 = result_0[35:27];

  assign result_0_3 = result_0[26:18];

  assign result_0_4 = result_0[17:9];

  assign result_0_5 = result_0[8:0];

  assign result_0_0_0 = $signed(result_0_0[8:1]);

  assign result_0_0_1 = result_0_0[0:0];

  assign result_0_1_0 = $signed(result_0_1[8:1]);

  assign result_0_1_1 = result_0_1[0:0];

  assign result_0_2_0 = $signed(result_0_2[8:1]);

  assign result_0_2_1 = result_0_2[0:0];

  assign result_0_3_0 = $signed(result_0_3[8:1]);

  assign result_0_3_1 = result_0_3[0:0];

  assign result_0_4_0 = $signed(result_0_4[8:1]);

  assign result_0_4_1 = result_0_4[0:0];

  assign result_0_5_0 = $signed(result_0_5[8:1]);

  assign result_0_5_1 = result_0_5[0:0];

  assign result_1_0 = result_1[23:23];

  assign result_1_1 = result_1[22:22];

  assign result_1_2 = result_1[21:21];

  assign result_1_3 = result_1[20:20];

  assign result_1_4 = result_1[19:17];

  assign result_1_5 = $signed(result_1[16:9]);

  assign result_1_6 = $signed(result_1[8:1]);

  assign result_1_7 = result_1[0:0];


endmodule

