/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.6.4. DO NOT MODIFY.
*/
`timescale 100fs/100fs
module topEntity
    ( // Inputs
      input  clk // clock
    , input  rst // reset
    , input  en // enable
    , input signed [63:0] input0_0
    , input  input0_1

      // Outputs
    , output wire  result_0
    , output wire  result_1_0
    , output wire signed [63:0] result_1_1
    , output wire  result_1_2
    , output wire signed [63:0] result_1_3
    );
  reg [129:0] result_2 = {1'b0,   64'sd0,   1'b0,   64'sd0};
  wire [129:0] result_3;
  // periodicEnable/periodicEnable.hs:61:1-118
  wire [129:0] t;
  // periodicEnable/periodicEnable.hs:61:1-118
  wire signed [63:0] curTime;
  wire  result_4;
  wire signed [63:0] result_5;
  wire signed [63:0] x;
  reg signed [63:0] result_6 = 64'sd2000;
  wire  result_7;
  // periodicEnable/periodicEnable.hs:61:1-118
  wire  b;
  // periodicEnable/periodicEnable.hs:61:1-118
  wire  c$b_app_arg;
  wire [129:0] result_8;
  // periodicEnable/periodicEnable.hs:12:1-73
  wire  b_0;
  wire  result_9;
  // periodicEnable/periodicEnable.hs:19:5-74
  wire  b_1;
  // periodicEnable/periodicEnable.hs:19:5-74
  wire signed [63:0] t_0;
  wire signed [63:0] result_10;
  reg signed [63:0] result_11 = 64'sd0;
  reg  result_12 = 1'b0;
  wire [64:0] input0;
  wire [130:0] result;
  wire [129:0] result_1_4;

  assign input0 = {input0_0,   input0_1};

  assign result = {result_12,   result_8};

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_2_register
    if ( rst) begin
      result_2 <= {1'b0,   64'sd0,   1'b0,   64'sd0};
    end else if (en) begin
      result_2 <= result_3;
    end
  end
  // register end

  assign result_3 = result_12 ? t : {result_2[129:129],
                                     result_6,   result_7,   curTime};

  assign t = {result_4,   result_6,   result_7,
              curTime};

  assign curTime = $signed(result_2[128:65]);

  assign result_4 = c$b_app_arg ? 1'b1 : 1'b0;

  assign result_5 = result_7 ? 64'sd2000 : (x + 64'sd2000);

  assign x = result_6;

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_6_register
    if ( rst) begin
      result_6 <= 64'sd2000;
    end else if (en) begin
      result_6 <= result_5;
    end
  end
  // register end

  assign result_7 = b ? 1'b1 : 1'b0;

  assign b = result_12 & c$b_app_arg;

  assign c$b_app_arg = result_6 >= 64'sd100000;

  assign result_8 = {result_2[129:129],
                     $signed(result_2[128:65]),   result_2[64:64],
                     $signed(result_2[63:0])};

  assign b_0 = result_11 < 64'sd2;

  assign result_9 = b_0 ? 1'b1 : 1'b0;

  assign b_1 = result_11 < 64'sd4;

  assign t_0 = result_11 + 64'sd1;

  assign result_10 = b_1 ? t_0 : 64'sd0;

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_11_register
    if ( rst) begin
      result_11 <= 64'sd0;
    end else if (en) begin
      result_11 <= result_10;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_12_register
    if ( rst) begin
      result_12 <= 1'b0;
    end else if (en) begin
      result_12 <= result_9;
    end
  end
  // register end

  assign result_0 = result[130:130];

  assign result_1_4 = result[129:0];

  assign result_1_0 = result_1_4[129:129];

  assign result_1_1 = $signed(result_1_4[128:65]);

  assign result_1_2 = result_1_4[64:64];

  assign result_1_3 = $signed(result_1_4[63:0]);


endmodule

