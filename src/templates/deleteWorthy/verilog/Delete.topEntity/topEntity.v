/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.6.4. DO NOT MODIFY.
*/
`timescale 100fs/100fs
module topEntity
    ( // Inputs
      input  clk // clock
    , input  rst // reset
    , input  en // enable
    , input signed [63:0] input0_0
    , input  input0_1

      // Outputs
    , output wire  result_0
    , output wire  result_1_0
    , output wire signed [63:0] result_1_1
    );
  reg [65:0] result_2 = {1'b0,   64'sd0,   1'b0};
  wire [65:0] result_3;
  // deleteWorthy/delete.hs:53:1-113
  wire [65:0] t;
  wire  result_4;
  wire signed [63:0] result_5;
  wire signed [63:0] x;
  reg signed [63:0] result_6 = 64'sd0;
  wire  result_7;
  // deleteWorthy/delete.hs:53:1-113
  wire  b;
  // deleteWorthy/delete.hs:53:1-113
  wire  c$b_app_arg;
  // deleteWorthy/delete.hs:53:1-113
  wire signed [63:0] curTime;
  wire [64:0] result_8;
  // deleteWorthy/delete.hs:12:1-73
  wire  b_0;
  wire  result_9;
  // deleteWorthy/delete.hs:19:5-74
  wire  b_1;
  // deleteWorthy/delete.hs:19:5-74
  wire signed [63:0] t_0;
  wire signed [63:0] result_10;
  reg signed [63:0] result_11 = 64'sd0;
  reg  result_12 = 1'b0;
  wire [64:0] input0;
  wire [65:0] result;
  wire [64:0] result_1_2;

  assign input0 = {input0_0,   input0_1};

  assign result = {result_12,   result_8};

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_2_register
    if ( rst) begin
      result_2 <= {1'b0,   64'sd0,   1'b0};
    end else if (en) begin
      result_2 <= result_3;
    end
  end
  // register end

  assign result_3 = result_12 ? t : {result_2[65:65],
                                     result_6,   result_2[0:0]};

  assign t = {result_4,   result_6,   result_7};

  assign result_4 = c$b_app_arg ? 1'b1 : 1'b0;

  assign result_5 = result_7 ? 64'sd0 : (x + 64'sd2000);

  assign x = result_6;

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_6_register
    if ( rst) begin
      result_6 <= 64'sd0;
    end else if (en) begin
      result_6 <= result_5;
    end
  end
  // register end

  assign result_7 = b ? 1'b1 : 1'b0;

  assign b = result_12 & c$b_app_arg;

  assign c$b_app_arg = curTime >= 64'sd100000;

  assign curTime = $signed(result_2[64:1]);

  assign result_8 = {result_2[65:65],
                     $signed(result_2[64:1])};

  assign b_0 = result_11 < 64'sd2;

  assign result_9 = b_0 ? 1'b1 : 1'b0;

  assign b_1 = result_11 < 64'sd4;

  assign t_0 = result_11 + 64'sd1;

  assign result_10 = b_1 ? t_0 : 64'sd0;

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_11_register
    if ( rst) begin
      result_11 <= 64'sd0;
    end else if (en) begin
      result_11 <= result_10;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_12_register
    if ( rst) begin
      result_12 <= 1'b0;
    end else if (en) begin
      result_12 <= result_9;
    end
  end
  // register end

  assign result_0 = result[65:65];

  assign result_1_2 = result[64:0];

  assign result_1_0 = result_1_2[64:64];

  assign result_1_1 = $signed(result_1_2[63:0]);


endmodule

