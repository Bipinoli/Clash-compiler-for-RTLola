/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.6.4. DO NOT MODIFY.
*/
`timescale 100fs/100fs
module topEntity
    ( // Inputs
      input  clk // clock
    , input  rst // reset
    , input  en // enable
    , input signed [31:0] x1
    , input signed [31:0] x2
    , input  newX1
    , input  newX2

      // Outputs
    , output wire signed [31:0] result_0
    , output wire signed [31:0] result_1_0
    , output wire signed [31:0] result_1_1
    , output wire signed [31:0] result_1_2
    );
  // simple_event_based/simple_event_based.hs:39:1-116
  reg signed [31:0] cur = -32'sd1;
  // simple_event_based/simple_event_based.hs:39:1-116
  reg signed [31:0] past1 = -32'sd1;
  // simple_event_based/simple_event_based.hs:39:1-116
  reg signed [31:0] past2 = -32'sd1;
  wire [95:0] result_2;
  // simple_event_based/simple_event_based.hs:39:1-116
  wire signed [31:0] c$past2_app_arg;
  // simple_event_based/simple_event_based.hs:39:1-116
  wire signed [31:0] c$past1_app_arg;
  // simple_event_based/simple_event_based.hs:39:1-116
  wire signed [31:0] c$cur_app_arg;
  reg  c$app_arg = 1'b0;
  reg  c$app_arg_0 = 1'b0;
  reg  result_3 = 1'b0;
  // simple_event_based/simple_event_based.hs:79:1-9
  reg signed [31:0] holdX2 = -32'sd1;
  // simple_event_based/simple_event_based.hs:79:1-9
  reg signed [31:0] holdX1 = -32'sd1;
  // simple_event_based/simple_event_based.hs:52:1-113
  wire signed [31:0] t;
  wire signed [31:0] result_4;
  reg signed [31:0] result_5 = 32'sd0;
  reg  c$app_arg_1 = 1'b0;
  reg  result_6 = 1'b0;
  // simple_event_based/simple_event_based.hs:79:1-9
  wire signed [31:0] c$holdX1_app_arg;
  // simple_event_based/simple_event_based.hs:79:1-9
  wire signed [31:0] c$holdX2_app_arg;
  wire [127:0] result;
  wire [95:0] result_1_3;

  assign result = {result_5,   result_2};

  // register begin
  always @(posedge clk or  posedge  rst) begin : cur_register
    if ( rst) begin
      cur <= -32'sd1;
    end else if (en) begin
      cur <= c$cur_app_arg;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : past1_register
    if ( rst) begin
      past1 <= -32'sd1;
    end else if (en) begin
      past1 <= c$past1_app_arg;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : past2_register
    if ( rst) begin
      past2 <= -32'sd1;
    end else if (en) begin
      past2 <= c$past2_app_arg;
    end
  end
  // register end

  assign result_2 = {cur,   past1,   past2};

  assign c$past2_app_arg = result_3 ? past1 : past2;

  assign c$past1_app_arg = result_3 ? cur : past1;

  assign c$cur_app_arg = result_3 ? result_5 : cur;

  // register begin
  always @(posedge clk or  posedge  rst) begin : c$app_arg_register
    if ( rst) begin
      c$app_arg <= 1'b0;
    end else if (en) begin
      c$app_arg <= c$app_arg_0;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : c$app_arg_0_register
    if ( rst) begin
      c$app_arg_0 <= 1'b0;
    end else if (en) begin
      c$app_arg_0 <= newX1;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_3_register
    if ( rst) begin
      result_3 <= 1'b0;
    end else if (en) begin
      result_3 <= c$app_arg;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : holdX2_register
    if ( rst) begin
      holdX2 <= -32'sd1;
    end else if (en) begin
      holdX2 <= c$holdX2_app_arg;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : holdX1_register
    if ( rst) begin
      holdX1 <= -32'sd1;
    end else if (en) begin
      holdX1 <= c$holdX1_app_arg;
    end
  end
  // register end

  assign t = holdX1 + holdX2;

  assign result_4 = result_6 ? t : result_5;

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_5_register
    if ( rst) begin
      result_5 <= 32'sd0;
    end else if (en) begin
      result_5 <= result_4;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : c$app_arg_1_register
    if ( rst) begin
      c$app_arg_1 <= 1'b0;
    end else if (en) begin
      c$app_arg_1 <= newX1;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_6_register
    if ( rst) begin
      result_6 <= 1'b0;
    end else if (en) begin
      result_6 <= c$app_arg_1;
    end
  end
  // register end

  assign c$holdX1_app_arg = newX1 ? x1 : holdX1;

  assign c$holdX2_app_arg = newX2 ? x2 : holdX2;

  assign result_0 = $signed(result[127:96]);

  assign result_1_3 = result[95:0];

  assign result_1_0 = $signed(result_1_3[95:64]);

  assign result_1_1 = $signed(result_1_3[63:32]);

  assign result_1_2 = $signed(result_1_3[31:0]);


endmodule

