/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.6.4. DO NOT MODIFY.
*/
`timescale 100fs/100fs
module topEntity
    ( // Inputs
      input  clk // clock
    , input  rst // reset
    , input  en // enable
    , input  input0_0_0
    , input  input0_0_1
    , input  input0_1_0
    , input  input0_1_1
    , input signed [63:0] input0_2_0
    , input  input0_2_1

      // Outputs
    , output wire  result_0_0
    , output wire signed [63:0] result_0_1
    , output wire  result_1_0
    , output wire  result_1_1
    , output wire signed [63:0] result_1_2
    , output wire  result_1_3
    , output wire  result_1_4
    , output wire  result_1_5
    , output wire  result_1_6
    , output wire  result_1_7
    , output wire  result_1_8
    , output wire signed [63:0] result_2_0
    , output wire  result_2_1_0
    , output wire  result_2_1_1
    , output wire  result_2_2_0
    , output wire  result_2_2_1
    , output wire  result_2_3_0
    , output wire  result_2_3_1
    , output wire  result_2_4_0
    , output wire  result_2_4_1
    , output wire  result_2_5_0
    , output wire  result_2_5_1
    , output wire signed [63:0] result_2_6_0
    , output wire  result_2_6_1
    );
  wire [138:0] result_3;
  // bool_and_comp/bool_and_comp.hs:169:1-103
  wire  eta;
  wire signed [63:0] result_4;
  reg signed [63:0] result_5 = 64'sd0;
  // bool_and_comp/bool_and_comp.hs:157:1-109
  wire  eta_0;
  wire  result_6;
  // bool_and_comp/bool_and_comp.hs:157:1-109
  wire  t;
  reg  result_7 = 1'b0;
  // bool_and_comp/bool_and_comp.hs:163:1-99
  wire  eta_1;
  // bool_and_comp/bool_and_comp.hs:163:1-99
  wire  t_0;
  wire  result_8;
  reg  result_9 = 1'b0;
  // bool_and_comp/bool_and_comp.hs:(121,1)-(132,17)
  wire  a;
  // bool_and_comp/bool_and_comp.hs:187:1-106
  wire  eta_2;
  wire  result_10;
  // bool_and_comp/bool_and_comp.hs:187:1-106
  wire  t_1;
  reg  result_11 = 1'b0;
  // bool_and_comp/bool_and_comp.hs:175:1-96
  wire  eta_3;
  // bool_and_comp/bool_and_comp.hs:175:1-96
  wire  t_2;
  wire  result_12;
  reg  result_13 = 1'b0;
  // bool_and_comp/bool_and_comp.hs:181:1-96
  wire  eta_4;
  // bool_and_comp/bool_and_comp.hs:181:1-96
  wire  t_3;
  wire  result_14;
  reg  result_15 = 1'b0;
  // bool_and_comp/bool_and_comp.hs:(121,1)-(132,17)
  wire signed [63:0] id;
  // bool_and_comp/bool_and_comp.hs:(121,1)-(132,17)
  wire  c$outLt_app_arg;
  wire [5:0] result_16;
  // bool_and_comp/bool_and_comp.hs:(121,1)-(132,17)
  wire  b;
  // bool_and_comp/bool_and_comp.hs:(121,1)-(132,17)
  wire  enLt;
  // bool_and_comp/bool_and_comp.hs:(121,1)-(132,17)
  wire  enGt;
  // bool_and_comp/bool_and_comp.hs:(121,1)-(132,17)
  wire  enNeq;
  // bool_and_comp/bool_and_comp.hs:(121,1)-(132,17)
  wire  enNotA;
  // bool_and_comp/bool_and_comp.hs:(121,1)-(132,17)
  wire  enAImplB;
  // bool_and_comp/bool_and_comp.hs:(121,1)-(132,17)
  wire  enTimeStream;
  reg signed [63:0] c$app_arg = 64'sd0;
  // bool_and_comp/bool_and_comp.hs:40:1-64
  reg signed [63:0] s = 64'sd0;
  // bool_and_comp/bool_and_comp.hs:40:1-64
  wire  b_0;
  wire signed [63:0] result_17;
  wire signed [63:0] x;
  reg [64:0] result_18 = {1'b0,   64'sd0};
  wire [64:0] result_19;
  // bool_and_comp/bool_and_comp.hs:105:1-114
  wire  b_1;
  // bool_and_comp/bool_and_comp.hs:105:1-114
  wire [64:0] f1;
  // bool_and_comp/bool_and_comp.hs:105:1-114
  wire [64:0] t_4;
  wire  result_20;
  // bool_and_comp/bool_and_comp.hs:105:1-114
  wire  c$b_app_arg;
  wire signed [63:0] result_21;
  wire signed [63:0] x_0;
  reg signed [63:0] result_22 = 64'sd2000;
  wire  result_23;
  // bool_and_comp/bool_and_comp.hs:105:1-114
  wire  b_2;
  // bool_and_comp/bool_and_comp.hs:105:1-114
  wire  en_0;
  wire [71:0] result_24;
  // bool_and_comp/bool_and_comp.hs:(78,1)-(82,51)
  wire  aktvId;
  // bool_and_comp/bool_and_comp.hs:(78,1)-(82,51)
  wire  aktvA;
  reg [71:0] result_25 = {1'b0,   1'b0,   64'sd0,   1'b0,   1'b0,   1'b0,   1'b0,   1'b0,   1'b0};
  // bool_and_comp/bool_and_comp.hs:14:1-76
  wire  b_3;
  wire [64:0] result_26;
  // bool_and_comp/bool_and_comp.hs:25:5-66
  wire  b_4;
  wire signed [63:0] result_27;
  wire signed [63:0] x_1;
  reg signed [63:0] result_28 = 64'sd0;
  reg [64:0] result_29 = {1'b0,   64'sd0};
  wire [68:0] input0;
  wire [275:0] result;
  wire [64:0] result_0;
  wire [71:0] result_1;
  wire [138:0] result_2;
  wire [1:0] result_2_1;
  wire [1:0] result_2_2;
  wire [1:0] result_2_3;
  wire [1:0] result_2_4;
  wire [1:0] result_2_5;
  wire [64:0] result_2_6;

  assign input0 = {{input0_0_0,   input0_0_1},
                   {input0_1_0,   input0_1_1},   {input0_2_0,
                                                  input0_2_1}};

  assign result = {result_29,   result_25,
                   result_3};

  assign result_3 = {c$app_arg,   {result_15,
                                   result_16[5:5]},   {result_13,
                                                       result_16[4:4]},   {result_11,
                                                                           result_16[3:3]},   {result_9,
                                                                                               result_16[2:2]},
                     {result_7,   result_16[1:1]},   {result_5,
                                                      result_16[0:0]}};

  assign eta = c$outLt_app_arg & enTimeStream;

  assign result_4 = eta ? id : result_5;

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_5_register
    if ( rst) begin
      result_5 <= 64'sd0;
    end else if (en) begin
      result_5 <= result_4;
    end
  end
  // register end

  assign eta_0 = c$outLt_app_arg & enAImplB;

  assign result_6 = eta_0 ? t : result_7;

  assign t = (~ a) | result_25[70:70];

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_7_register
    if ( rst) begin
      result_7 <= 1'b0;
    end else if (en) begin
      result_7 <= result_6;
    end
  end
  // register end

  assign eta_1 = c$outLt_app_arg & enNotA;

  assign t_0 = ~ a;

  assign result_8 = eta_1 ? t_0 : result_9;

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_9_register
    if ( rst) begin
      result_9 <= 1'b0;
    end else if (en) begin
      result_9 <= result_8;
    end
  end
  // register end

  assign a = result_25[71:71];

  assign eta_2 = (c$app_arg == 64'sd3) & enNeq;

  assign result_10 = eta_2 ? t_1 : result_11;

  assign t_1 = result_15 | result_13;

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_11_register
    if ( rst) begin
      result_11 <= 1'b0;
    end else if (en) begin
      result_11 <= result_10;
    end
  end
  // register end

  assign eta_3 = c$outLt_app_arg & enGt;

  assign t_2 = id > 64'sd5;

  assign result_12 = eta_3 ? t_2 : result_13;

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_13_register
    if ( rst) begin
      result_13 <= 1'b0;
    end else if (en) begin
      result_13 <= result_12;
    end
  end
  // register end

  assign eta_4 = c$outLt_app_arg & enLt;

  assign t_3 = id < 64'sd5;

  assign result_14 = eta_4 ? t_3 : result_15;

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_15_register
    if ( rst) begin
      result_15 <= 1'b0;
    end else if (en) begin
      result_15 <= result_14;
    end
  end
  // register end

  assign id = $signed(result_25[69:6]);

  assign c$outLt_app_arg = c$app_arg == 64'sd2;

  assign result_16 = b ? {enLt,   enGt,   enNeq,
                          enNotA,   enAImplB,   enTimeStream} : {1'b0,
                                                                 1'b0,   1'b0,   1'b0,   1'b0,   1'b0};

  assign b = c$app_arg == 64'sd4;

  assign enLt = result_25[5:5];

  assign enGt = result_25[4:4];

  assign enNeq = result_25[3:3];

  assign enNotA = result_25[2:2];

  assign enAImplB = result_25[1:1];

  assign enTimeStream = result_25[0:0];

  // delay begin
  always @(posedge clk) begin : c$app_arg_delay
    if (en) begin
      c$app_arg <= s;
    end
  end
  // delay end

  // register begin
  always @(posedge clk or  posedge  rst) begin : s_register
    if ( rst) begin
      s <= 64'sd0;
    end else if (en) begin
      s <= result_17;
    end
  end
  // register end

  assign b_0 = s == 64'sd4;

  assign result_17 = b_0 ? 64'sd0 : (x + 64'sd1);

  assign x = s;

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_18_register
    if ( rst) begin
      result_18 <= {1'b0,   64'sd0};
    end else if (en) begin
      result_18 <= result_19;
    end
  end
  // register end

  assign result_19 = b_1 ? t_4 : f1;

  assign b_1 = en_0 & ($signed(result_29[63:0]) == 64'sd0);

  assign f1 = {result_18[64:64],   result_22};

  assign t_4 = {result_20,   result_22};

  assign result_20 = c$b_app_arg ? 1'b1 : 1'b0;

  assign c$b_app_arg = result_22 >= 64'sd1000000000;

  assign result_21 = result_23 ? 64'sd2000 : (x_0 + 64'sd2000);

  assign x_0 = result_22;

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_22_register
    if ( rst) begin
      result_22 <= 64'sd2000;
    end else if (en) begin
      result_22 <= result_21;
    end
  end
  // register end

  assign result_23 = b_2 ? 1'b1 : 1'b0;

  assign b_2 = en_0 & c$b_app_arg;

  assign en_0 = result_29[64:64];

  assign result_24 = result_29[64:64] ? {input0[68:68],
                                         input0[66:66],   $signed(input0[64:1]),
                                         aktvId,   aktvId,   aktvId,   aktvA,
                                         aktvA & input0[65:65],
                                         result_18[64:64]} : result_25;

  assign aktvId = input0[0:0];

  assign aktvA = input0[67:67];

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_25_register
    if ( rst) begin
      result_25 <= {1'b0,   1'b0,   64'sd0,   1'b0,   1'b0,   1'b0,   1'b0,   1'b0,   1'b0};
    end else if (en) begin
      result_25 <= result_24;
    end
  end
  // register end

  assign b_3 = result_28 < 64'sd2;

  assign result_26 = b_3 ? {1'b1,
                            result_28} : {1'b0,   result_28};

  assign b_4 = result_28 < 64'sd4;

  assign result_27 = b_4 ? (x_1 + 64'sd1) : 64'sd0;

  assign x_1 = result_28;

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_28_register
    if ( rst) begin
      result_28 <= 64'sd0;
    end else if (en) begin
      result_28 <= result_27;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_29_register
    if ( rst) begin
      result_29 <= {1'b0,   64'sd0};
    end else if (en) begin
      result_29 <= result_26;
    end
  end
  // register end

  assign result_0 = result[275:211];

  assign result_1 = result[210:139];

  assign result_2 = result[138:0];

  assign result_0_0 = result_0[64:64];

  assign result_0_1 = $signed(result_0[63:0]);

  assign result_1_0 = result_1[71:71];

  assign result_1_1 = result_1[70:70];

  assign result_1_2 = $signed(result_1[69:6]);

  assign result_1_3 = result_1[5:5];

  assign result_1_4 = result_1[4:4];

  assign result_1_5 = result_1[3:3];

  assign result_1_6 = result_1[2:2];

  assign result_1_7 = result_1[1:1];

  assign result_1_8 = result_1[0:0];

  assign result_2_0 = $signed(result_2[138:75]);

  assign result_2_1 = result_2[74:73];

  assign result_2_2 = result_2[72:71];

  assign result_2_3 = result_2[70:69];

  assign result_2_4 = result_2[68:67];

  assign result_2_5 = result_2[66:65];

  assign result_2_6 = result_2[64:0];

  assign result_2_1_0 = result_2_1[1:1];

  assign result_2_1_1 = result_2_1[0:0];

  assign result_2_2_0 = result_2_2[1:1];

  assign result_2_2_1 = result_2_2[0:0];

  assign result_2_3_0 = result_2_3[1:1];

  assign result_2_3_1 = result_2_3[0:0];

  assign result_2_4_0 = result_2_4[1:1];

  assign result_2_4_1 = result_2_4[0:0];

  assign result_2_5_0 = result_2_5[1:1];

  assign result_2_5_1 = result_2_5[0:0];

  assign result_2_6_0 = $signed(result_2_6[64:1]);

  assign result_2_6_1 = result_2_6[0:0];


endmodule

