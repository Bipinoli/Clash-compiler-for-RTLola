/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.8.2. DO NOT MODIFY.
*/
`default_nettype none
`timescale 100fs/100fs
module topEntity
    ( // Inputs
      input wire  eta // clock
    , input wire  eta1 // reset
    , input wire  eta2 // enable
    , input wire  eta_0
    , input wire  eta_1
    , input wire signed [63:0] eta_2

      // Outputs
    , output wire  result_0
    , output wire  result_1
    , output wire signed [63:0] result_2
    , output wire signed [63:0] result_3
    );
  // time_tracking_queue.hs:36:1-78
  reg [127:0] ds = {64'sd0,   -64'sd1};
  reg  c$app_arg = 1'b0;
  wire  c$case_alt;
  reg  c$case_alt_0;
  reg  c$app_arg_0 = 1'b0;
  wire  c$case_alt_1;
  // time_tracking_queue.hs:36:1-78
  wire [127:0] c$ds_case_alt;
  // time_tracking_queue.hs:36:1-78
  reg [127:0] c$ds_case_alt_0;
  // time_tracking_queue.hs:36:1-78
  wire signed [63:0] x1;
  // time_tracking_queue.hs:36:1-78
  wire signed [63:0] c$ds_case_scrut;
  // time_tracking_queue.hs:36:1-78
  wire signed [63:0] c$ds_app_arg;
  // time_tracking_queue.hs:36:1-78
  reg [319:0] \wait  = {64'sd0,   64'sd0,   64'sd0,   64'sd0,   64'sd0};
  // time_tracking_queue.hs:36:1-78
  wire [319:0] c$wait_case_alt;
  // time_tracking_queue.hs:36:1-78
  wire [1289:0] c$wait_app_arg;
  // time_tracking_queue.hs:36:1-78
  wire [959:0] c$wait_app_arg_0;
  // time_tracking_queue.hs:36:1-78
  wire [639:0] c$wait_app_arg_1;
  // time_tracking_queue.hs:36:1-78
  reg [319:0] buffer = {64'sd0,   64'sd0,   64'sd0,   64'sd0,   64'sd0};
  // time_tracking_queue.hs:36:1-78
  wire [319:0] c$buffer_case_alt;
  // time_tracking_queue.hs:36:1-78
  wire [319:0] c$buffer_case_alt_0;
  // time_tracking_queue.hs:36:1-78
  wire signed [63:0] qData;
  // time_tracking_queue.hs:36:1-78
  reg signed [63:0] cursor = (64'sd0);
  // time_tracking_queue.hs:36:1-78
  wire signed [63:0] c$cursor_case_alt;
  // time_tracking_queue.hs:36:1-78
  wire  push;
  // time_tracking_queue.hs:36:1-78
  wire signed [63:0] c$cursor_case_alt_0;
  // time_tracking_queue.hs:36:1-78
  reg signed [63:0] c$cursor_case_alt_1;
  // time_tracking_queue.hs:36:1-78
  wire signed [63:0] c$cursor_case_alt_2;
  // time_tracking_queue.hs:36:1-78
  wire  c$cursor_case_scrut;
  // time_tracking_queue.hs:36:1-78
  wire signed [63:0] x;
  // time_tracking_queue.hs:36:1-78
  wire signed [63:0] c$cursor_case_alt_3;
  // time_tracking_queue.hs:36:1-78
  wire  pop;
  // time_tracking_queue.hs:36:1-78
  reg signed [63:0] c$cursor_case_alt_4;
  // time_tracking_queue.hs:36:1-78
  wire signed [63:0] c$cursor_case_alt_5;
  wire [65:0] eta_3;
  wire [329:0] c$vec1;
  wire [319:0] c$wait_app_arg_res;
  wire [319:0] c$vec1_0;
  wire [383:0] c$buffer_case_alt_sel_alt_t_1;
  wire signed [63:0] c$tte_rhs_2;
  wire [129:0] result;

  assign eta_3 = {eta_0,   eta_1,   eta_2};

  assign result = {c$app_arg_0,   c$app_arg,
                   $signed(ds[127:64]),   $signed(ds[63:0])};

  // register begin
  always @(posedge eta or  posedge  eta1) begin : ds_register
    if ( eta1) begin
      ds <= {64'sd0,   -64'sd1};
    end else if (eta2) begin
      ds <= c$ds_case_alt;
    end
  end
  // register end

  // register begin
  always @(posedge eta or  posedge  eta1) begin : c$app_arg_register
    if ( eta1) begin
      c$app_arg <= 1'b0;
    end else if (eta2) begin
      c$app_arg <= c$case_alt;
    end
  end
  // register end

  assign c$case_alt = pop ? c$case_alt_0 : 1'b0;

  always @(*) begin
    case(x)
      64'sd0 : c$case_alt_0 = 1'b0;
      default : c$case_alt_0 = 1'b1;
    endcase
  end

  // register begin
  always @(posedge eta or  posedge  eta1) begin : c$app_arg_0_register
    if ( eta1) begin
      c$app_arg_0 <= 1'b0;
    end else if (eta2) begin
      c$app_arg_0 <= c$case_alt_1;
    end
  end
  // register end

  assign c$case_alt_1 = push ? c$cursor_case_scrut : 1'b0;

  assign c$ds_case_alt = pop ? c$ds_case_alt_0 : {64'sd0,
                                                  -64'sd1};

  always @(*) begin
    case(x)
      64'sd0 : c$ds_case_alt_0 = {64'sd0,
                                  -64'sd1};
      default : c$ds_case_alt_0 = {c$ds_app_arg,
                                   (x1 + 64'sd1)};
    endcase
  end

  assign x1 = c$ds_case_scrut;

  // index begin
  wire signed [63:0] vecArray [0:5-1];
  genvar i;
  generate
  for (i=0; i < 5; i=i+1) begin : mk_array
    assign vecArray[(5-1)-i] = \wait [i*64+:64];
  end
  endgenerate
  assign c$ds_case_scrut = vecArray[c$cursor_case_alt_5];
  // index end

  // index begin
  wire signed [63:0] vecArray_0 [0:5-1];
  genvar i_0;
  generate
  for (i_0=0; i_0 < 5; i_0=i_0+1) begin : mk_array_0
    assign vecArray_0[(5-1)-i_0] = buffer[i_0*64+:64];
  end
  endgenerate
  assign c$ds_app_arg = vecArray_0[c$cursor_case_alt_5];
  // index end

  // register begin
  always @(posedge eta or  posedge  eta1) begin : wait_register
    if ( eta1) begin
      \wait  <= {64'sd0,   64'sd0,   64'sd0,   64'sd0,   64'sd0};
    end else if (eta2) begin
      \wait  <= c$wait_case_alt;
    end
  end
  // register end

  // map begin
  genvar i_1;
  generate
  for (i_1=0; i_1 < 5; i_1 = i_1 + 1) begin : map
    wire [257:0] map_in;
    assign map_in = c$wait_app_arg[i_1*258+:258];
    wire signed [63:0] map_out;
    wire signed [63:0] c$case_alt_5;
    // time_tracking_queue.hs:36:1-78
    wire  push1;
    wire signed [63:0] c$case_alt_6;
    wire signed [63:0] c$case_alt_7;
    // time_tracking_queue.hs:36:1-78
    wire  pop1;
    reg signed [63:0] c$case_alt_8;
    wire signed [63:0] c$case_alt_9;
    reg signed [63:0] c$case_alt_10;
    wire signed [63:0] c$case_alt_11;
    wire  c$case_scrut;
    wire signed [63:0] c$case_alt_12;
    // time_tracking_queue.hs:36:1-78
    wire signed [63:0] x1_1;
    // time_tracking_queue.hs:36:1-78
    wire signed [63:0] valToLeft;
    wire signed [63:0] c$case_alt_13;
    wire  c$case_scrut_0;
    wire signed [63:0] c$case_alt_14;
    wire  c$case_scrut_1;
    wire signed [63:0] c$case_alt_15;
    // time_tracking_queue.hs:36:1-78
    wire signed [63:0] x1_2;
    // time_tracking_queue.hs:36:1-78
    wire signed [63:0] val;
    // time_tracking_queue.hs:36:1-78
    wire signed [63:0] y;
    // time_tracking_queue.hs:36:1-78
    wire signed [63:0] cur1;
    // time_tracking_queue.hs:36:1-78
    wire signed [63:0] x_0;
    // time_tracking_queue.hs:36:1-78
    wire signed [63:0] index;
    wire signed [63:0] c$tte_rhs;
    wire signed [63:0] c$tte_rhs_0;
    wire signed [63:0] c$tte_rhs_1;
    assign map_out = c$case_alt_5;

    assign c$case_alt_5 = push1 ? c$case_alt_6 : c$case_alt_7;

    assign push1 = map_in[1:1];

    assign c$case_alt_6 = pop1 ? c$case_alt_8 : c$case_alt_10;

    assign c$case_alt_7 = pop1 ? c$case_alt_13 : c$case_alt_14;

    assign pop1 = map_in[0:0];

    always @(*) begin
      case(x_0)
        64'sd0 : c$case_alt_8 = 64'sd0;
        default : c$case_alt_8 = c$case_alt_9;
      endcase
    end

    assign c$case_alt_9 = c$case_scrut_1 ? c$case_alt_12 : (-64'sd1);

    always @(*) begin
      case(x_0)
        64'sd0 : c$case_alt_10 = 64'sd0;
        default : c$case_alt_10 = c$case_alt_11;
      endcase
    end

    assign c$case_alt_11 = c$case_scrut ? c$case_alt_12 : (-64'sd1);

    assign c$tte_rhs = (x_0 <= y) ? 64'sd1 : 64'sd0;

    assign c$case_scrut = c$tte_rhs[0];

    assign c$case_alt_12 = (x1_1 + 64'sd1);

    assign x1_1 = valToLeft;

    assign valToLeft = $signed(map_in[257:194]);

    assign c$case_alt_13 = c$case_scrut_0 ? c$case_alt_15 : (-64'sd1);

    assign c$tte_rhs_0 = (x_0 < (y - 64'sd1)) ? 64'sd1 : 64'sd0;

    assign c$case_scrut_0 = c$tte_rhs_0[0];

    assign c$case_alt_14 = c$case_scrut_1 ? c$case_alt_15 : (-64'sd1);

    assign c$tte_rhs_1 = (x_0 < y) ? 64'sd1 : 64'sd0;

    assign c$case_scrut_1 = c$tte_rhs_1[0];

    assign c$case_alt_15 = (x1_2 + 64'sd1);

    assign x1_2 = val;

    assign val = $signed(map_in[193:130]);

    assign y = cur1;

    assign cur1 = $signed(map_in[65:2]);

    assign x_0 = index;

    assign index = $signed(map_in[129:66]);


    assign c$wait_case_alt[i_1*64+:64] = map_out;
  end
  endgenerate
  // map end

  assign c$vec1 = ({5 {{push,   pop,   cursor}}});

  // zipWith start
  genvar i_3;
  generate
  for (i_3 = 0; i_3 < 5; i_3 = i_3 + 1) begin : zipWith
    wire [65:0] zipWith_in1;
    assign zipWith_in1 = c$vec1[i_3*66+:66];
    wire [191:0] zipWith_in2;
    assign zipWith_in2 = c$wait_app_arg_0[i_3*192+:192];
    wire [257:0] c$n;
    // time_tracking_queue.hs:36:1-78
    wire  psh;
    // time_tracking_queue.hs:36:1-78
    wire  pp;
    // time_tracking_queue.hs:36:1-78
    wire signed [63:0] c;
    // time_tracking_queue.hs:36:1-78
    wire signed [63:0] i_2;
    // time_tracking_queue.hs:36:1-78
    wire signed [63:0] valToLeft_1;
    // time_tracking_queue.hs:36:1-78
    wire signed [63:0] val_1;
    wire [257:0] c$case_alt_16;
    assign c$n = c$case_alt_16;

    assign psh = zipWith_in1[65:65];

    assign pp = zipWith_in1[64:64];

    assign c = $signed(zipWith_in1[63:0]);

    assign i_2 = $signed(zipWith_in2[191:128]);

    assign valToLeft_1 = $signed(zipWith_in2[127:64]);

    assign val_1 = $signed(zipWith_in2[63:0]);

    assign c$case_alt_16 = {valToLeft_1,   val_1,
                            i_2,   c,   psh,   pp};


    assign c$wait_app_arg[i_3*258+:258] = c$n;
  end
  endgenerate
  // zipWith end

  wire signed [63:0] iterateI_ho1_0_arg0;
  wire signed [63:0] iterateI_ho1_0_res;
  wire signed [63:0] iterateI_ho1_1_res;
  wire signed [63:0] iterateI_ho1_2_res;
  wire signed [63:0] iterateI_ho1_3_res;
  assign iterateI_ho1_0_arg0 = (64'sd0);

  // time_tracking_queue.hs:36:1-78
  wire signed [63:0] x1_3;
  wire signed [63:0] c$case_alt_17;
  assign iterateI_ho1_0_res = c$case_alt_17;

  assign x1_3 = iterateI_ho1_0_arg0;

  assign c$case_alt_17 = (x1_3 + 64'sd1);



  // time_tracking_queue.hs:36:1-78
  wire signed [63:0] x1_4;
  wire signed [63:0] c$case_alt_18;
  assign iterateI_ho1_1_res = c$case_alt_18;

  assign x1_4 = iterateI_ho1_0_res;

  assign c$case_alt_18 = (x1_4 + 64'sd1);



  // time_tracking_queue.hs:36:1-78
  wire signed [63:0] x1_5;
  wire signed [63:0] c$case_alt_19;
  assign iterateI_ho1_2_res = c$case_alt_19;

  assign x1_5 = iterateI_ho1_1_res;

  assign c$case_alt_19 = (x1_5 + 64'sd1);



  // time_tracking_queue.hs:36:1-78
  wire signed [63:0] x1_6;
  wire signed [63:0] c$case_alt_20;
  assign iterateI_ho1_3_res = c$case_alt_20;

  assign x1_6 = iterateI_ho1_2_res;

  assign c$case_alt_20 = (x1_6 + 64'sd1);



  assign c$wait_app_arg_res = {(64'sd0),
                               iterateI_ho1_0_res,   iterateI_ho1_1_res,
                               iterateI_ho1_2_res,   iterateI_ho1_3_res};



  // zipWith start
  genvar i_4;
  generate
  for (i_4 = 0; i_4 < 5; i_4 = i_4 + 1) begin : zipWith_0
    wire signed [63:0] zipWith_in1_0;
    assign zipWith_in1_0 = c$wait_app_arg_res[i_4*64+:64];
    wire [127:0] zipWith_in2_0;
    assign zipWith_in2_0 = c$wait_app_arg_1[i_4*128+:128];
    wire [191:0] c$n_0;
    // time_tracking_queue.hs:36:1-78
    wire signed [63:0] b1;
    // time_tracking_queue.hs:36:1-78
    wire signed [63:0] c1;
    wire [191:0] c$case_alt_21;
    assign c$n_0 = c$case_alt_21;

    assign b1 = $signed(zipWith_in2_0[127:64]);

    assign c1 = $signed(zipWith_in2_0[63:0]);

    assign c$case_alt_21 = {zipWith_in1_0,   b1,
                            c1};


    assign c$wait_app_arg_0[i_4*192+:192] = c$n_0;
  end
  endgenerate
  // zipWith end

  assign c$vec1_0 = ({64'sd0,(\wait [320-1 : 64])});

  // zipWith start
  genvar i_5;
  generate
  for (i_5 = 0; i_5 < 5; i_5 = i_5 + 1) begin : zipWith_1
    wire signed [63:0] zipWith_in1_1;
    assign zipWith_in1_1 = c$vec1_0[i_5*64+:64];
    wire signed [63:0] zipWith_in2_1;
    assign zipWith_in2_1 = \wait [i_5*64+:64];
    wire [127:0] c$n_1;
    assign c$n_1 = {zipWith_in1_1,   zipWith_in2_1};


    assign c$wait_app_arg_1[i_5*128+:128] = c$n_1;
  end
  endgenerate
  // zipWith end

  // register begin
  always @(posedge eta or  posedge  eta1) begin : buffer_register
    if ( eta1) begin
      buffer <= {64'sd0,   64'sd0,   64'sd0,   64'sd0,   64'sd0};
    end else if (eta2) begin
      buffer <= c$buffer_case_alt;
    end
  end
  // register end

  assign c$buffer_case_alt = push ? c$buffer_case_alt_0 : buffer;

  assign c$buffer_case_alt_sel_alt_t_1 = ({qData,buffer});

  assign c$buffer_case_alt_0 = c$cursor_case_scrut ? c$buffer_case_alt_sel_alt_t_1[383:64] : buffer;

  assign qData = $signed(eta_3[63:0]);

  // register begin
  always @(posedge eta or  posedge  eta1) begin : cursor_register
    if ( eta1) begin
      cursor <= (64'sd0);
    end else if (eta2) begin
      cursor <= c$cursor_case_alt;
    end
  end
  // register end

  assign c$cursor_case_alt = push ? c$cursor_case_alt_0 : c$cursor_case_alt_3;

  assign push = eta_3[65:65];

  assign c$cursor_case_alt_0 = pop ? c$cursor_case_alt_1 : c$cursor_case_alt_2;

  always @(*) begin
    case(x)
      64'sd0 : c$cursor_case_alt_1 = 64'sd1;
      default : c$cursor_case_alt_1 = cursor;
    endcase
  end

  assign c$cursor_case_alt_2 = c$cursor_case_scrut ? ((x + 64'sd1)) : cursor;

  assign c$tte_rhs_2 = (x != 64'sd5) ? 64'sd1 : 64'sd0;

  assign c$cursor_case_scrut = c$tte_rhs_2[0];

  assign x = cursor;

  assign c$cursor_case_alt_3 = pop ? c$cursor_case_alt_4 : cursor;

  assign pop = eta_3[64:64];

  always @(*) begin
    case(x)
      64'sd0 : c$cursor_case_alt_4 = 64'sd0;
      default : c$cursor_case_alt_4 = c$cursor_case_alt_5;
    endcase
  end

  assign c$cursor_case_alt_5 = (x - 64'sd1);

  assign result_0 = result[129:129];

  assign result_1 = result[128:128];

  assign result_2 = $signed(result[127:64]);

  assign result_3 = $signed(result[63:0]);


endmodule

