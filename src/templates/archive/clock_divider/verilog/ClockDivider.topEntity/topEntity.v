/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.6.4. DO NOT MODIFY.
*/
`timescale 100fs/100fs
module topEntity
    ( // Inputs
      input  eta // clock
    , input  eta1 // reset
    , input  eta2 // enable

      // Outputs
    , output wire  result_0
    , output wire  result_1
    , output wire  result_2
    , output wire  result_3
    , output wire  result_4
    );
  // archive/clock_divider/clock_divider.hs:8:1-73
  wire  b;
  wire  result_10;
  // archive/clock_divider/clock_divider.hs:15:5-74
  wire  b_0;
  // archive/clock_divider/clock_divider.hs:15:5-74
  wire signed [63:0] t;
  wire signed [63:0] result_11;
  reg signed [63:0] result_12 = 64'sd0;
  reg  result_13 = 1'b0;
  // archive/clock_divider/clock_divider.hs:8:1-73
  wire  b_1;
  wire  result_14;
  // archive/clock_divider/clock_divider.hs:15:5-74
  wire  b_2;
  // archive/clock_divider/clock_divider.hs:15:5-74
  wire signed [63:0] t_0;
  wire signed [63:0] result_15;
  reg signed [63:0] result_16 = 64'sd0;
  reg  result_17 = 1'b0;
  // archive/clock_divider/clock_divider.hs:8:1-73
  wire  b_3;
  wire  result_18;
  // archive/clock_divider/clock_divider.hs:15:5-74
  wire  b_4;
  // archive/clock_divider/clock_divider.hs:15:5-74
  wire signed [63:0] t_1;
  wire signed [63:0] result_19;
  reg signed [63:0] result_20 = 64'sd0;
  reg  result_21 = 1'b0;
  // archive/clock_divider/clock_divider.hs:8:1-73
  wire  b_5;
  wire  result_22;
  // archive/clock_divider/clock_divider.hs:15:5-74
  wire  b_6;
  // archive/clock_divider/clock_divider.hs:15:5-74
  wire signed [63:0] t_2;
  wire signed [63:0] result_23;
  reg signed [63:0] result_24 = 64'sd0;
  reg  result_25 = 1'b0;
  // archive/clock_divider/clock_divider.hs:8:1-73
  wire  b_7;
  wire  result_26;
  // archive/clock_divider/clock_divider.hs:15:5-74
  wire  b_8;
  // archive/clock_divider/clock_divider.hs:15:5-74
  wire signed [63:0] t_3;
  wire signed [63:0] result_27;
  reg signed [63:0] result_28 = 64'sd0;
  reg  result_29 = 1'b0;
  wire [4:0] result;

  assign b = result_12 < 64'sd0;

  assign result_10 = b ? 1'b1 : 1'b0;

  assign b_0 = result_12 < 64'sd0;

  assign t = result_12 + 64'sd1;

  assign result_11 = b_0 ? t : 64'sd0;

  // register begin
  always @(posedge eta or  posedge  eta1) begin : result_12_register
    if ( eta1) begin
      result_12 <= 64'sd0;
    end else if (eta2) begin
      result_12 <= result_11;
    end
  end
  // register end

  // register begin
  always @(posedge eta or  posedge  eta1) begin : result_13_register
    if ( eta1) begin
      result_13 <= 1'b0;
    end else if (eta2) begin
      result_13 <= result_10;
    end
  end
  // register end

  assign b_1 = result_16 < 64'sd3;

  assign result_14 = b_1 ? 1'b1 : 1'b0;

  assign b_2 = result_16 < 64'sd5;

  assign t_0 = result_16 + 64'sd1;

  assign result_15 = b_2 ? t_0 : 64'sd0;

  // register begin
  always @(posedge eta or  posedge  eta1) begin : result_16_register
    if ( eta1) begin
      result_16 <= 64'sd0;
    end else if (eta2) begin
      result_16 <= result_15;
    end
  end
  // register end

  // register begin
  always @(posedge eta or  posedge  eta1) begin : result_17_register
    if ( eta1) begin
      result_17 <= 1'b0;
    end else if (eta2) begin
      result_17 <= result_14;
    end
  end
  // register end

  assign b_3 = result_20 < 64'sd2;

  assign result_18 = b_3 ? 1'b1 : 1'b0;

  assign b_4 = result_20 < 64'sd4;

  assign t_1 = result_20 + 64'sd1;

  assign result_19 = b_4 ? t_1 : 64'sd0;

  // register begin
  always @(posedge eta or  posedge  eta1) begin : result_20_register
    if ( eta1) begin
      result_20 <= 64'sd0;
    end else if (eta2) begin
      result_20 <= result_19;
    end
  end
  // register end

  // register begin
  always @(posedge eta or  posedge  eta1) begin : result_21_register
    if ( eta1) begin
      result_21 <= 1'b0;
    end else if (eta2) begin
      result_21 <= result_18;
    end
  end
  // register end

  assign b_5 = result_24 < 64'sd1;

  assign result_22 = b_5 ? 1'b1 : 1'b0;

  assign b_6 = result_24 < 64'sd1;

  assign t_2 = result_24 + 64'sd1;

  assign result_23 = b_6 ? t_2 : 64'sd0;

  // register begin
  always @(posedge eta or  posedge  eta1) begin : result_24_register
    if ( eta1) begin
      result_24 <= 64'sd0;
    end else if (eta2) begin
      result_24 <= result_23;
    end
  end
  // register end

  // register begin
  always @(posedge eta or  posedge  eta1) begin : result_25_register
    if ( eta1) begin
      result_25 <= 1'b0;
    end else if (eta2) begin
      result_25 <= result_22;
    end
  end
  // register end

  assign b_7 = result_28 < 64'sd2;

  assign result_26 = b_7 ? 1'b1 : 1'b0;

  assign b_8 = result_28 < 64'sd3;

  assign t_3 = result_28 + 64'sd1;

  assign result_27 = b_8 ? t_3 : 64'sd0;

  // register begin
  always @(posedge eta or  posedge  eta1) begin : result_28_register
    if ( eta1) begin
      result_28 <= 64'sd0;
    end else if (eta2) begin
      result_28 <= result_27;
    end
  end
  // register end

  // register begin
  always @(posedge eta or  posedge  eta1) begin : result_29_register
    if ( eta1) begin
      result_29 <= 1'b0;
    end else if (eta2) begin
      result_29 <= result_26;
    end
  end
  // register end

  assign result = {result_29,   result_25,
                   result_21,   result_17,   result_13};

  assign result_0 = result[4:4];

  assign result_1 = result[3:3];

  assign result_2 = result[2:2];

  assign result_3 = result[1:1];

  assign result_4 = result[0:0];


endmodule

