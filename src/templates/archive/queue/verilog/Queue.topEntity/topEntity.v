/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.8.2. DO NOT MODIFY.
*/
`default_nettype none
`timescale 100fs/100fs
module topEntity
    ( // Inputs
      input wire  eta // clock
    , input wire  eta1 // reset
    , input wire  eta2 // enable
    , input wire  eta_0
    , input wire  eta_1
    , input wire signed [63:0] eta_2

      // Outputs
    , output wire  result_0
    , output wire  result_1
    , output wire signed [63:0] result_2
    , output wire signed [63:0] result_3_0_0
    , output wire signed [63:0] result_3_0_1
    , output wire signed [63:0] result_3_0_2
    , output wire signed [63:0] result_3_0_3
    , output wire signed [63:0] result_3_0_4
    , output wire signed [63:0] result_3_1
    );
  reg signed [63:0] c$app_arg = (64'sd0);
  wire signed [63:0] c$case_alt;
  reg signed [63:0] c$case_alt_0;
  wire signed [63:0] c$case_alt_1;
  reg  c$app_arg_0 = 1'b0;
  wire  c$case_alt_2;
  reg  c$case_alt_3;
  reg  c$app_arg_1 = 1'b0;
  wire  c$case_alt_4;
  // queue.hs:31:1-78
  reg [319:0] buffer = {64'sd0,   64'sd0,   64'sd0,   64'sd0,   64'sd0};
  // queue.hs:31:1-78
  wire [319:0] c$buffer_case_alt;
  // queue.hs:31:1-78
  wire [319:0] c$buffer_case_alt_0;
  // queue.hs:31:1-78
  wire signed [63:0] qData;
  // queue.hs:31:1-78
  reg signed [63:0] cursor = (64'sd0);
  // queue.hs:31:1-78
  wire signed [63:0] c$cursor_case_alt;
  // queue.hs:31:1-78
  wire  push;
  // queue.hs:31:1-78
  wire signed [63:0] c$cursor_case_alt_0;
  // queue.hs:31:1-78
  reg signed [63:0] c$cursor_case_alt_1;
  // queue.hs:31:1-78
  wire signed [63:0] c$cursor_case_alt_2;
  // queue.hs:31:1-78
  wire  c$cursor_case_scrut;
  // queue.hs:31:1-78
  wire signed [63:0] x;
  // queue.hs:31:1-78
  wire signed [63:0] c$cursor_case_alt_3;
  // queue.hs:31:1-78
  wire  pop;
  // queue.hs:31:1-78
  reg signed [63:0] c$cursor_case_alt_4;
  // queue.hs:31:1-78
  wire signed [63:0] c$cursor_case_alt_5;
  wire [65:0] eta_3;
  wire [383:0] c$buffer_case_alt_sel_alt_t_1;
  wire signed [63:0] c$tte_rhs;
  wire [449:0] result;
  wire [383:0] result_3_2;
  wire [319:0] result_3_0;

  assign eta_3 = {eta_0,   eta_1,   eta_2};

  assign result = {c$app_arg_1,   c$app_arg_0,
                   c$app_arg,   {buffer,   cursor}};

  // register begin
  always @(posedge eta or  posedge  eta1) begin : c$app_arg_register
    if ( eta1) begin
      c$app_arg <= (64'sd0);
    end else if (eta2) begin
      c$app_arg <= c$case_alt;
    end
  end
  // register end

  assign c$case_alt = pop ? c$case_alt_0 : (64'sd0);

  always @(*) begin
    case(x)
      64'sd0 : c$case_alt_0 = 64'sd0;
      default : c$case_alt_0 = c$case_alt_1;
    endcase
  end

  // index begin
  wire signed [63:0] vecArray [0:5-1];
  genvar i;
  generate
  for (i=0; i < 5; i=i+1) begin : mk_array
    assign vecArray[(5-1)-i] = buffer[i*64+:64];
  end
  endgenerate
  assign c$case_alt_1 = vecArray[c$cursor_case_alt_5];
  // index end

  // register begin
  always @(posedge eta or  posedge  eta1) begin : c$app_arg_0_register
    if ( eta1) begin
      c$app_arg_0 <= 1'b0;
    end else if (eta2) begin
      c$app_arg_0 <= c$case_alt_2;
    end
  end
  // register end

  assign c$case_alt_2 = pop ? c$case_alt_3 : 1'b0;

  always @(*) begin
    case(x)
      64'sd0 : c$case_alt_3 = 1'b0;
      default : c$case_alt_3 = 1'b1;
    endcase
  end

  // register begin
  always @(posedge eta or  posedge  eta1) begin : c$app_arg_1_register
    if ( eta1) begin
      c$app_arg_1 <= 1'b0;
    end else if (eta2) begin
      c$app_arg_1 <= c$case_alt_4;
    end
  end
  // register end

  assign c$case_alt_4 = push ? c$cursor_case_scrut : 1'b0;

  // register begin
  always @(posedge eta or  posedge  eta1) begin : buffer_register
    if ( eta1) begin
      buffer <= {64'sd0,   64'sd0,   64'sd0,   64'sd0,   64'sd0};
    end else if (eta2) begin
      buffer <= c$buffer_case_alt;
    end
  end
  // register end

  assign c$buffer_case_alt = push ? c$buffer_case_alt_0 : buffer;

  assign c$buffer_case_alt_sel_alt_t_1 = ({qData,buffer});

  assign c$buffer_case_alt_0 = c$cursor_case_scrut ? c$buffer_case_alt_sel_alt_t_1[383:64] : buffer;

  assign qData = $signed(eta_3[63:0]);

  // register begin
  always @(posedge eta or  posedge  eta1) begin : cursor_register
    if ( eta1) begin
      cursor <= (64'sd0);
    end else if (eta2) begin
      cursor <= c$cursor_case_alt;
    end
  end
  // register end

  assign c$cursor_case_alt = push ? c$cursor_case_alt_0 : c$cursor_case_alt_3;

  assign push = eta_3[65:65];

  assign c$cursor_case_alt_0 = pop ? c$cursor_case_alt_1 : c$cursor_case_alt_2;

  always @(*) begin
    case(x)
      64'sd0 : c$cursor_case_alt_1 = 64'sd1;
      default : c$cursor_case_alt_1 = cursor;
    endcase
  end

  assign c$cursor_case_alt_2 = c$cursor_case_scrut ? ((x + 64'sd1)) : cursor;

  assign c$tte_rhs = (x != 64'sd5) ? 64'sd1 : 64'sd0;

  assign c$cursor_case_scrut = c$tte_rhs[0];

  assign x = cursor;

  assign c$cursor_case_alt_3 = pop ? c$cursor_case_alt_4 : cursor;

  assign pop = eta_3[64:64];

  always @(*) begin
    case(x)
      64'sd0 : c$cursor_case_alt_4 = 64'sd0;
      default : c$cursor_case_alt_4 = c$cursor_case_alt_5;
    endcase
  end

  assign c$cursor_case_alt_5 = (x - 64'sd1);

  assign result_0 = result[449:449];

  assign result_1 = result[448:448];

  assign result_2 = $signed(result[447:384]);

  assign result_3_2 = result[383:0];

  assign result_3_0 = result_3_2[383:64];

  assign result_3_1 = $signed(result_3_2[63:0]);

  assign result_3_0_0 = $signed(result_3_0[319:256]);

  assign result_3_0_1 = $signed(result_3_0[255:192]);

  assign result_3_0_2 = $signed(result_3_0[191:128]);

  assign result_3_0_3 = $signed(result_3_0[127:64]);

  assign result_3_0_4 = $signed(result_3_0[63:0]);


endmodule

