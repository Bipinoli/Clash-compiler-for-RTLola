/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.6.4. DO NOT MODIFY.
*/
`timescale 100fs/100fs
module topEntity
    ( // Inputs
      input  clk // clock
    , input  rst // reset
    , input  en // enable
    , input signed [31:0] x
    , input  newX

      // Outputs
    , output wire signed [31:0] result_0
    , output wire signed [31:0] result_1
    , output wire signed [31:0] result_2_0
    , output wire signed [31:0] result_2_1
    , output wire signed [31:0] result_2_2
    );
  // simple_cycle/simple_cycle.hs:50:1-94
  wire signed [31:0] t;
  wire signed [31:0] result_4;
  reg signed [31:0] result_5 = 32'sd0;
  reg  result_6 = 1'b0;
  wire signed [31:0] result_7;
  // simple_cycle/simple_cycle.hs:44:1-127
  wire signed [31:0] t_0;
  reg signed [31:0] result_8 = 32'sd0;
  // simple_cycle/simple_cycle.hs:36:1-116
  wire signed [31:0] eta1;
  // simple_cycle/simple_cycle.hs:36:1-116
  reg signed [31:0] cur = 32'sd0;
  // simple_cycle/simple_cycle.hs:36:1-116
  reg signed [31:0] past1 = 32'sd0;
  // simple_cycle/simple_cycle.hs:36:1-116
  reg signed [31:0] past2 = 32'sd0;
  wire [95:0] result_9;
  // simple_cycle/simple_cycle.hs:36:1-116
  wire signed [31:0] c$past2_app_arg;
  // simple_cycle/simple_cycle.hs:36:1-116
  wire signed [31:0] c$past1_app_arg;
  // simple_cycle/simple_cycle.hs:36:1-116
  wire signed [31:0] c$cur_app_arg;
  reg  c$app_arg = 1'b0;
  reg  result_10 = 1'b0;
  wire [159:0] result;
  wire [95:0] result_2_3;

  assign result = {result_8,   result_5,
                   result_9};

  assign t = result_8 + 32'sd1;

  assign result_4 = result_6 ? t : result_5;

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_5_register
    if ( rst) begin
      result_5 <= 32'sd0;
    end else if (en) begin
      result_5 <= result_4;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_6_register
    if ( rst) begin
      result_6 <= 1'b0;
    end else if (en) begin
      result_6 <= newX;
    end
  end
  // register end

  assign result_7 = newX ? t_0 : result_8;

  assign t_0 = x + $signed(result_9[63:32]);

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_8_register
    if ( rst) begin
      result_8 <= 32'sd0;
    end else if (en) begin
      result_8 <= result_7;
    end
  end
  // register end

  assign eta1 = result_5 + 32'sd1;

  // register begin
  always @(posedge clk or  posedge  rst) begin : cur_register
    if ( rst) begin
      cur <= 32'sd0;
    end else if (en) begin
      cur <= c$cur_app_arg;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : past1_register
    if ( rst) begin
      past1 <= 32'sd0;
    end else if (en) begin
      past1 <= c$past1_app_arg;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : past2_register
    if ( rst) begin
      past2 <= 32'sd0;
    end else if (en) begin
      past2 <= c$past2_app_arg;
    end
  end
  // register end

  assign result_9 = {cur,   past1,   past2};

  assign c$past2_app_arg = result_10 ? past1 : past2;

  assign c$past1_app_arg = result_10 ? cur : past1;

  assign c$cur_app_arg = result_10 ? eta1 : cur;

  // register begin
  always @(posedge clk or  posedge  rst) begin : c$app_arg_register
    if ( rst) begin
      c$app_arg <= 1'b0;
    end else if (en) begin
      c$app_arg <= newX;
    end
  end
  // register end

  // register begin
  always @(posedge clk or  posedge  rst) begin : result_10_register
    if ( rst) begin
      result_10 <= 1'b0;
    end else if (en) begin
      result_10 <= c$app_arg;
    end
  end
  // register end

  assign result_0 = $signed(result[159:128]);

  assign result_1 = $signed(result[127:96]);

  assign result_2_3 = result[95:0];

  assign result_2_0 = $signed(result_2_3[95:64]);

  assign result_2_1 = $signed(result_2_3[63:32]);

  assign result_2_2 = $signed(result_2_3[31:0]);


endmodule

