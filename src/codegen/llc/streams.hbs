{{#if has_pipeline_wait}}
pipelineReady :: HiddenClockResetEnable dom => Signal dom Bool -> Signal dom Bool
pipelineReady rst = toWait .==. pure 0 
    where 
        waitTime = pure {{pipeline_wait}} :: Signal dom Int
        toWait = register (0 :: Int) next
        next = mux rst waitTime (mux (toWait .>. pure 0) (toWait - 1) toWait)
{{/if}}

{{#each input_streams}}

{{#if this.is_accessed_by_offset}}
input{{@index}}Window :: HiddenClockResetEnable dom => Signal dom Bool -> Signal dom {{this.data_type}} -> Signal dom (Vec {{this.memory}} {{this.data_type}}, Vec {{this.memory}} Bool)
input{{@index}}Window en d = bundle (dataOut, validOut)
    where 
        dataOut = register (repeat {{this.default_value}}) (mux en ((<<+) <$> dataOut <*> d) dataOut)
        validOut = register (repeat False) (mux en ((<<+) <$> validOut <*> pure True) validOut)
{{else}}
input{{@index}}Window :: HiddenClockResetEnable dom => Signal dom Bool -> Signal dom {{this.data_type}} -> Signal dom {{this.data_type}}
input{{@index}}Window en d = out
    where out = register {{this.default_value}} (mux en d out)
{{/if}}

{{/each}}

{{#each output_streams}}

{{#if this.is_sliding_window_based}}
{{#if (gt this.memory 1) }}
outputStream{{@index}} :: HiddenClockResetEnable dom => Signal dom Bool -> {{#each this.input_types}}Signal dom {{this}}{{#unless @last}} -> {{/unless}}{{/each}} -> Signal dom (Vec {{this.memory}}) {{this.output_type}})
{{else}}
outputStream{{@index}} :: HiddenClockResetEnable dom => Signal dom Bool -> {{#each this.input_types}}Signal dom {{this}}{{#unless @last}} -> {{/unless}}{{/each}} -> Signal dom {{this.output_type}}
{{/if}}
outputStream{{@index}} en {{#each this.inputs}}{{this}}WithTag {{/each}}= result
    where
        {{#if (gt this.memory 1)}}
        result = register (repeat (0 :: Tag, {{this.default_value}})) (mux en next result)
        next = (<<+) <$> next <*> nextValWithTag
        {{else}}
        result = register (0 :: Tag, {{this.default_value}}) (mux en nextValWithTag result)
        {{/if}}
        nextValWithTag = bundle (tag, nextVal)
        nextVal = {{{this.expression}}}
        {{#each this.inputs}}
        ({{#if @first}}tag{{else}}_{{/if}}, {{this}}) = unbundle {{this}}WithTag
        {{/each}}
        {{#each this.sliding_window_inputs}}
        merge{{this.window_idx}} :: Vec {{this.window_size}} {{this.data_type}} -> {{this.data_type}}
        merge{{this.window_idx}} win = fold windowBucketFunc{{this.window_idx}} win
        {{/each}}
{{else}}
{{#if (gt this.memory 1) }}
outputStream{{@index}} :: HiddenClockResetEnable dom => Signal dom Bool -> {{#each this.input_types}}Signal dom {{this}}{{#unless @last}} -> {{/unless}}{{/each}} -> Signal dom (Vec {{this.memory}} {{this.output_type}})
{{else}}
outputStream{{@index}} :: HiddenClockResetEnable dom => Signal dom Bool -> {{#each this.input_types}}Signal dom {{this}}{{#unless @last}} -> {{/unless}}{{/each}} -> Signal dom {{this.output_type}}
{{/if}}
outputStream{{@index}} en {{#each this.inputs}}{{this}}WithTag {{/each}}= result
    where
        {{#if (gt this.memory 1)}}
        result = register (repeat (0 :: Tag, {{this.default_value}})) (mux en next result)
        next = (<<+) <$> next <*> nextValWithTag
        {{else}}
        result = register (0 :: Tag, {{this.default_value}}) (mux en nextValWithTag result)
        {{/if}}
        nextValWithTag = bundle (tag, nextVal)
        nextVal = {{{this.expression}}}
        {{#each this.inputs}}
        ({{#if @first}}tag{{else}}_{{/if}}, {{this}}) = unbundle {{this}}WithTag
        {{/each}}
{{/if}}

{{/each}}

{{#if has_sliding_window}}
{{#each bucket_functions}}
windowBucketFunc{{@index}} :: {{this.data_type}} -> {{this.data_type}} -> {{this.data_type}}
windowBucketFunc{{@index}} acc item = {{this.expression}}

{{/each}}
{{/if}}

{{#if has_sliding_window}}
{{#each sliding_windows}}
{{#if (gt this.memory 1)}}
slidingWindow{{@index}} :: HiddenClockResetEnable dom => Signal dom Bool -> Signal dom Bool -> Signal dom ({{this.data_type}}, Bool) -> Signal dom (Vec {{this.memory}} (Vec {{this.window_size}} {{this.data_type}})) 
{{else}}
slidingWindow{{@index}} :: HiddenClockResetEnable dom => Signal dom Bool -> Signal dom Bool -> Signal dom ({{this.data_type}}, Bool) -> Signal dom (Vec {{this.window_size}} {{this.data_type}})
{{/if}}
slidingWindow{{@index}} en slide hasInput = window
    where
        {{#if (gt this.memory 1)}}
        window = register (repeat dflt) (mux en next window)
        next = (<<+) <$> next <*> nextVal
        nextVal = nextWindow <$> (last <$> window) <*> slide <*> hasInput
        {{else}}
        window = register dflt (mux en next window)
        next = nextWindow <$> window <*> slide <*> hasInput
        {{/if}}
        dflt = repeat {{this.default_value}} :: Vec {{this.window_size}} {{this.data_type}}

        nextWindow :: Vec {{this.window_size}} {{this.data_type}} -> Bool -> ({{this.data_type}}, Bool) -> Vec {{this.window_size}} {{this.data_type}}
        nextWindow win toSlide inpt = out
            where
                (dta, hasData) = inpt
                out = case (toSlide, hasData) of
                    (False, False) -> win
                    (False, True) -> updatedWin
                    (True, False) -> win <<+ 0
                updatedWin = replace lastIndx (windowBucketFunc{{@index}} (last win) dta) win
                lastIndx = length win - 1       


{{/each}}
{{/if}}