{{#if has_pipeline_wait}}
pipelineReady :: HiddenClockResetEnable dom => Signal dom Bool -> Signal dom Bool
pipelineReady rst = toWait .==. pure 0 
    where 
        waitTime = pure {{pipeline_wait}} :: Signal dom Int
        toWait = register (0 :: Int) next
        next = mux rst waitTime (mux (toWait .>. pure 0) (toWait - 1) toWait)
{{/if}}

{{#each input_streams}}

{{#if this.is_accessed_by_offset}}
input{{@index}}Window :: HiddenClockResetEnable dom => Signal dom Bool -> Signal dom {{this.data_type}} -> Signal dom (Vec {{this.memory}} {{this.data_type}}, Vec {{this.memory}} Bool)
input{{@index}}Window en d = bundle (dataOut, validOut)
    where 
        dataOut = register (repeat {{this.default_value}}) (mux en ((<<+) <$> dataOut <*> d) dataOut)
        validOut = register (repeat False) (mux en ((<<+) <$> validOut <*> pure True) validOut)
{{else}}
input{{@index}}Window :: HiddenClockResetEnable dom => Signal dom Bool -> Signal dom {{this.data_type}} -> Signal dom {{this.data_type}}
input{{@index}}Window en d = out
    where out = register {{this.default_value}} (mux en d out)
{{/if}}

{{/each}}

{{#each output_streams}}

{{#if this.is_sliding_window_based}}
outputStream{{@index}} :: HiddenClockResetEnable dom => Signal dom Bool -> {{#each this.input_types}}Signal dom {{this}}{{#unless @last}} -> {{/unless}}{{/each}} -> Signal dom {{this.output_type}}
outputStream{{@index}} en {{this.inputs}} = result
    where
        result = register {{this.default_value}} (mux en next result)
        next = {{{this.expression}}}
        {{#each this.sliding_window_inputs}}
        merge{{this.window_idx}} :: Vec {{this.window_size}} {{this.data_type}} -> {{this.data_type}}
        merge{{this.window_idx}} win = fold windowBucketFunc{{this.window_idx}} win
        {{/each}}
{{else}}
outputStream{{@index}} :: HiddenClockResetEnable dom => Signal dom Bool -> {{#each this.input_types}}Signal dom {{this}}{{#unless @last}} -> {{/unless}}{{/each}} -> Signal dom {{this.output_type}}
outputStream{{@index}} en {{this.inputs}} = result
    where
        result = register {{this.default_value}} (mux en next result)
        next = {{{this.expression}}}
{{/if}}

{{/each}}

{{#if has_sliding_window}}
{{#each bucket_functions}}
windowBucketFunc{{@index}} :: {{this.data_type}} -> {{this.data_type}} -> {{this.data_type}}
windowBucketFunc{{@index}} acc item = {{this.expression}}

{{/each}}
{{/if}}

{{#if has_sliding_window}}
{{#each sliding_windows}}
slidingWindow{{@index}} :: HiddenClockResetEnable dom => Signal dom Bool -> Signal dom Bool -> Signal dom ({{this.data_type}}, Bool) -> Signal dom (Vec {{this.window_size}} {{this.data_type}})
slidingWindow{{@index}} en slide hasInput = window
    where
        window = register dflt (mux en next window)
        dflt = repeat {{this.default_value}} :: Vec {{this.window_size}} {{this.data_type}}
        next = nextWindow <$> window <*> slide <*> hasInput

        nextWindow :: Vec {{this.window_size}} {{this.data_type}} -> Bool -> ({{this.data_type}}, Bool) -> Vec {{this.window_size}} {{this.data_type}}
        nextWindow win toSlide inpt = out
            where
                (dta, hasData) = inpt
                out = case (toSlide, hasData) of
                    (False, False) -> win
                    (False, True) -> updatedWin
                    (True, False) -> win <<+ 0
                updatedWin = replace lastIndx (windowBucketFunc{{@index}} (last win) dta) win
                lastIndx = length win - 1       


{{/each}}
{{/if}}