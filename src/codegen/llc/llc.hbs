type Tag = Unsigned 8
-- maxTag must be at least the size of the sliding window to avoid duplicate tags in the window
maxTag = {{max_tag}} :: Tag

getOffset :: KnownNat n => Vec n (Tag, a) -> Tag -> Tag -> a -> a
getOffset win tag offset dflt = out
    where 
        offsetTag = if tag > offset then tag - offset else tag - offset + maxTag
        out = case findIndex (\(t, _) -> t == offsetTag) win of
            Just i -> let (_, v) = win !! i in v 
            Nothing -> dflt 



llc :: HiddenClockResetEnable dom => Signal dom Event -> Signal dom Outputs
llc event = outputs
    where 
        outputs = bundle (output0, output1, output2)

        input0win = input0Window enInpt0 input0
        input1win = input1Window enInpt1 input1

        out0 = outputStream0 enOut0 

        (inputs, slides, pacings) = unbundle event
        inputX = inputs
        pacingDEF = pacings

        (x, _) = unbundle inputX

        pacingD = unwrapPacingABCDEF <$> pacingDEF
        pacingE = delay False pacingD
        pacingF = delay False pacingE

        tag = genTag pacingD

        evalD = streamD pacingD (bundle (tag, x)) evalF 
        evalE = streamE pacingE evalD
        evalF = streamF pacingF evalE

        outAktvD = delay False (unwrapPacingABCDEF <$> pacingDEF)
        outAktvE = delay False outAktvD
        outAktvF = delay False outAktvE

        outputs = bundle (outputD, outputE, outputF)
        outputD = bundle (outD, outAktvD)
        outputE = bundle (outE, outAktvE)
        outputF = bundle (outF, outAktvF)
        (_, outD) = unbundle evalD
        (_, outE) = unbundle evalE
        (_, outF) = unbundle (last <$> evalF)

        genTag :: HiddenClockResetEnable dom => Signal dom Bool -> Signal dom Tag
        genTag en = t
            where 
                t = register 1 (mux en next_t t)
                next_t = mux (t .==. (pure maxTag)) (pure 1) (t + 1)




{{{streams}}}