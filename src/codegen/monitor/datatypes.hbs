{{#each all_unique_types}}
data Valid{{this}} = Valid{{this}} {
    value :: {{this}},
    valid :: Bool
} deriving (Generic, NFDataX)

{{/each}}

{{#if (gt (len inputs) 1)}}
data Inputs = Inputs {
    {{#each inputs}}
    input{{this.index}} :: Valid{{this.ty}}{{#unless @last}},{{/unless}}
    {{/each}}
} deriving (Generic, NFDataX)
{{else}}
    {{#if (eq (len inputs) 1)}}
-- using newtype to avoid flattening of data
-- https://clash-lang.discourse.group/t/how-to-avoid-flattening-of-fields-in-record/79/5
newtype Inputs = Inputs {
    {{#each inputs}}
    input0 :: Valid{{this.ty}}
    {{/each}}
} deriving (Generic, NFDataX)
    {{/if}}
{{/if}}

{{#if (gt (len outputs) 1)}}
data Outputs = Outputs {
    {{#each outputs}}
    output{{this.index}} :: Valid{{this.ty}}{{#unless @last}},{{/unless}}
    {{/each}}
} deriving (Generic, NFDataX)
{{else}}
-- using newtype to avoid flattening of data
-- https://clash-lang.discourse.group/t/how-to-avoid-flattening-of-fields-in-record/79/5
newtype Outputs = Outputs {
    {{#each outputs}}
    output{{this.index}} :: Valid{{this.ty}}
    {{/each}}
} deriving (Generic, NFDataX)
{{/if}}


class Pacing a where getPacing :: a -> Bool

{{#each inputs}}
data PacingIn{{@index}} = PacingIn{{@index}} Bool deriving (Generic, NFDataX)
{{/each}}
{{#each outputs}}
data PacingOut{{@index}} = PacingOut{{@index}} {{#if this.is_periodic}}Bool {{else}}{{#each this.pacing_deps}}Pacing{{this}} {{/each}}{{/if}}deriving (Generic, NFDataX)
{{/each}}

{{#each inputs}}
instance Pacing PacingIn{{@index}} where {{{this.get_pacing_stmt}}}
{{/each}}
{{#each outputs}}
instance Pacing PacingOut{{@index}} where {{{this.get_pacing_stmt}}}
{{/each}}

{{#if (or (gt (len outputs) 1) (and (gt (len inputs) 0) (gt (len outputs) 0)))}}
data Pacings = Pacings {
    {{#each inputs}}
    pacingIn{{@index}} :: PacingIn{{@index}},
    {{/each}}
    {{#each outputs}}
    pacingOut{{@index}} :: PacingOut{{@index}}{{#unless @last}},{{/unless}}
    {{/each}}
} deriving (Generic, NFDataX)
{{else}}
-- using newtype to avoid flattening of data
-- https://clash-lang.discourse.group/t/how-to-avoid-flattening-of-fields-in-record/79/5
newtype Pacings = Pacings {
    {{#each outputs}}
    pacingOut{{@index}} :: PacingOut{{@index}}{{#unless @last}},{{/unless}}
    {{/each}}
} deriving (Generic, NFDataX)
{{/if}}

{{#if has_sliding_window}}
{{#if (gt (len sliding_windows) 1)}}
data Slides = Slides {
    {{#each sliding_windows}}
    slide{{this.index}} :: Bool{{#unless @last}},{{/unless}}
    {{/each}}
} deriving (Generic, NFDataX)
{{else}}
-- using newtype to avoid flattening of data
-- https://clash-lang.discourse.group/t/how-to-avoid-flattening-of-fields-in-record/79/5
newtype Slides = Slides {
    slide0 :: Bool
} deriving (Generic, NFDataX)
{{/if}}
{{/if}}

type Tag = Unsigned 8

{{#if (gt (len all_streams) 1)}}
data Tags = Tags {
    {{#each all_streams}}
    {{this.stream_type}}{{this.index}} :: Tag{{#unless @last}},{{/unless}}
    {{/each}}
} deriving (Generic, NFDataX)
{{else}}
newtype Tags = Tags {
    {{#each all_streams}}
    {{this.stream_type}}{{this.index}} :: Tag{{#unless @last}},{{/unless}}
    {{/each}}
} deriving (Generic, NFDataX)
{{/if}}

type Event = ({{#if (gt (len inputs) 0)}}Inputs, {{/if}}{{#if has_sliding_window}}Slides, {{/if}}Pacings)

nullEvent :: Event
nullEvent = ({{#if (gt (len inputs) 0)}}nullInputs, {{/if}}{{#if has_sliding_window}}nullSlides, {{/if}}nullPacings)
{{#if (gt (len inputs) 0)}}
nullInputs = Inputs {{#each inputs}}(Valid{{this.ty}} {{this.default}} False) {{/each}}
{{/if}}
{{#if has_sliding_window}}
nullSlides = Slides {{#each sliding_windows}}False {{/each}}
{{/if}}
nullPacings = Pacings {{#each inputs}}nullPacingIn{{@index}} {{/each}}{{#each outputs}}nullPacingOut{{@index}} {{/each}}
{{#each inputs}}
nullPacingIn{{@index}} = PacingIn{{@index}} False
{{/each}}
{{#each outputs}}
{{#if this.is_periodic}}
nullPacingOut{{@index}} = PacingOut{{@index}} False 
{{else}}
nullPacingOut{{@index}} = PacingOut{{@index}} {{#each this.pacing_deps}}nullPacing{{this}} {{/each}}
{{/if}}
{{/each}}